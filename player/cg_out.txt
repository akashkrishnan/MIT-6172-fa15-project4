--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./leiserchess input.txt
Data file:        cachegrind.out.1706
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Thresholds:       0.1 100 100 100 100 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
            Ir  I1mr  ILmr            Dr      D1mr  DLmr            Dw      D1mw    DLmw            Bc         Bcm         Bi Bim 
--------------------------------------------------------------------------------
16,043,865,286 2,423 1,692 3,324,379,506 9,886,317 7,190 1,839,656,023 1,617,454 266,783 2,959,017,216 143,928,255 26,852,023 504  PROGRAM TOTALS

--------------------------------------------------------------------------------
           Ir I1mr ILmr          Dr      D1mr  DLmr          Dw    D1mw    DLmw          Bc        Bcm         Bi Bim  file:function
--------------------------------------------------------------------------------
4,618,007,711   79   29 943,345,195   315,305     7 238,261,439 143,296      16 857,191,330 65,278,771          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/eval.c:eval
3,964,381,923   17    9 475,867,553   254,797    30 451,961,790 157,171      30 870,439,591 23,582,666          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./search_common.c:scout_search.part.8
1,834,552,124   30   13 624,479,211 6,546,367     0 532,707,001 107,415      94 608,889,831 26,739,127          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/move_gen.c:make_move
1,051,609,793   64   25 193,425,831         3     1  79,089,194 418,750     151 177,937,278 16,791,653          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/move_gen.c:generate_all
  817,695,073    8    6 316,338,706   383,543     0  54,426,059      26       0 132,051,040  1,410,032          0   0  /build/buildd/eglibc-2.19/gmon/mcount.c:__mcount_internal
  580,610,914   14    5  26,457,780    80,107     0           0       0       0           0          0          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./././move_gen.h:eval
  568,322,246    4    4  48,077,489   390,542     0  25,577,735       0       0  89,242,353    914,668          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./search_common.c:get_sortable_move_list
  522,366,520    5    2 261,183,260         0     0 208,946,608 241,602      69           0          0          0   0  /build/buildd/eglibc-2.19/gmon/../sysdeps/x86_64/_mcount.S:mcount
  432,418,950   16   12 102,077,819    65,115     0 128,920,967   6,470      18  30,154,784  1,156,544          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./search_common.c:evaluateMove
  365,286,659    2    2  41,375,575       159     1           0       0       0   8,786,477     18,709          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./move_gen.h:make_move
  309,040,919   37    9 115,016,836   366,438     3  49,904,080  22,695      20  60,680,353  2,651,873          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./search_scout.c:scout_search.part.8
  308,582,275   25    5  25,617,573         1     0  20,630,369  63,683      24  11,666,464    364,616          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./move_gen.h:generate_all
  129,460,294    5    5  11,040,363    18,434     0     995,025      75       0  46,587,190    833,485          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/././move_gen.h:evaluateMove
   88,540,712    1    1  22,499,754         0     0     364,576       0       0           0          0          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/././move_gen.h:get_sortable_move_list
   82,016,088    6    4  16,547,488         2     1   2,187,462       0       0  16,226,331  1,027,054          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/eval.c:mark_laser_path
   60,275,152   18   11  19,378,126     2,938     0  10,959,533       6       0  14,396,115    973,719          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./search_scout.c:evaluateMove
   49,948,011   45   42   6,197,969    58,245     4   8,749,994  17,217      25   5,104,212         70          2   2  /build/buildd/eglibc-2.19/malloc/malloc.c:_int_malloc
   48,649,498    7    7  10,153,014       355     0   7,156,905       0       0   5,192,614    710,625          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./search_common.c:evaluate_as_leaf
   37,186,752   43   15  10,572,704    17,788     0   3,645,760       0       0   9,478,976         42          0   0  /build/buildd/eglibc-2.19/malloc/malloc.c:_int_free
   29,751,041    1    1     724,895         2     1           0       0       0           0          0          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./././move_gen.h:mark_laser_path
   26,868,916  140   98  26,848,389    92,868     1         199       1       1          69         23 26,848,203  98  ???:???
   18,772,219    0    0   1,497,081   109,311     0     892,561       0       0   1,043,691     43,982          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./search_globals.c:scout_search.part.8
   17,727,011   24   10   2,329,850    10,288    20   1,409,920     752      10   3,588,479     37,616          0   0  /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./search_common.c:searchPV

--------------------------------------------------------------------------------
-- Auto-annotated source: /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./search_globals.c
--------------------------------------------------------------------------------
       Ir I1mr ILmr        Dr   D1mr DLmr        Dw D1mw DLmw        Bc     Bcm Bi Bim 

-- line 8 ----------------------------------------
        .    .    .         .      .    .         .    .    .         .       .  .   .  // Format: best_move_history[color_t][piece_t][square_t][orientation]
        .    .    .         .      .    .         .    .    .         .       .  .   .  #define __BMH_dim__ [2*6*ARR_SIZE*NUM_ORI]  // NOLINT(whitespace/braces)
        .    .    .         .      .    .         .    .    .         .       .  .   .  #define BMH(color, piece, square, ori)                             \
        .    .    .         .      .    .         .    .    .         .       .  .   .      (color * 6 * ARR_SIZE * NUM_ORI + piece * ARR_SIZE * NUM_ORI + \
        .    .    .         .      .    .         .    .    .         .       .  .   .       square * NUM_ORI + ori)
        .    .    .         .      .    .         .    .    .         .       .  .   .  
        .    .    .         .      .    .         .    .    .         .       .  .   .  static int best_move_history __BMH_dim__;
        .    .    .         .      .    .         .    .    .         .       .  .   .  
        3    0    0         0      0    0         2    0    0         0       0  0   0  void init_best_move_history() {
        4    0    0         0      0    0         0    0    0         0       0  0   0    memset(best_move_history, 0, sizeof(best_move_history));
        1    0    0         1      0    0         0    0    0         0       0  0   0  }
        .    .    .         .      .    .         .    .    .         .       .  .   .  
        .    .    .         .      .    .         .    .    .         .       .  .   .  static void update_best_move_history(position_t *p, int index_of_best,
        .    .    .         .      .    .         .    .    .         .       .  .   .                                       sortable_move_t* lst, int count) {
        .    .    .         .      .    .         .    .    .         .       .  .   .    tbassert(ENABLE_TABLES, "Tables weren't enabled.\n");
        .    .    .         .      .    .         .    .    .         .       .  .   .  
  302,510    1    1   151,255      0    0         0    0    0         0       0  0   0    int color_to_move = color_to_move_of(p);
        .    .    .         .      .    .         .    .    .         .       .  .   .  
3,312,164    0    0   461,011 83,988    0         0    0    0 1,051,187  44,191  0   0    for (int i = 0; i < count; i++) {
        .    .    .         .      .    .         .    .    .         .       .  .   .      move_t   mv  = get_move(lst[i]);
        .    .    .         .      .    .         .    .    .         .       .  .   .      ptype_t  pce = ptype_mv_of(mv);
        .    .    .         .      .    .         .    .    .         .       .  .   .      rot_t    ro  = rot_of(mv);  // rotation
        .    .    .         .      .    .         .    .    .         .       .  .   .      square_t fs  = from_square(mv);
2,699,796    2    1         0      0    0         0    0    0         0       0  0   0      int      ot  = ORI_MASK & (ori_of(p->board[fs]) + ro);
        .    .    .         .      .    .         .    .    .         .       .  .   .      square_t ts  = to_square(mv);
        .    .    .         .      .    .         .    .    .         .       .  .   .  
6,299,524    0    0   899,932 25,722    0         0    0    0         0       0  0   0      int  s = best_move_history[BMH(color_to_move, pce, ts, ot)];
        .    .    .         .      .    .         .    .    .         .       .  .   .  
        .    .    .         .      .    .         .    .    .         .       .  .   .      if (index_of_best == i) {
2,699,796    0    0         0      0    0         0    0    0         0       0  0   0        s = s + 11200;  // number will never exceed 1017
        .    .    .         .      .    .         .    .    .         .       .  .   .      }
3,599,728    0    0         0      0    0   899,932    0    0         0       0  0   0      s = s * 0.90;  // decay score over time
        .    .    .         .      .    .         .    .    .         .       .  .   .  
        .    .    .         .      .    .         .    .    .         .       .  .   .      tbassert(s < 102000, "s = %d\n", s);  // or else sorting will fail
        .    .    .         .      .    .         .    .    .         .       .  .   .  
        .    .    .         .      .    .         .    .    .         .       .  .   .      best_move_history[BMH(color_to_move, pce, ts, ot)] = s;
        .    .    .         .      .    .         .    .    .         .       .  .   .    }
        .    .    .         .      .    .         .    .    .         .       .  .   .  }
        .    .    .         .      .    .         .    .    .         .       .  .   .  
2,187,456    2    2         0      0    0 1,458,304    0    0         0       0  0   0  static void update_transposition_table(searchNode* node) {
1,093,728    0    0   364,576     37    0         0    0    0   364,576  43,465  0   0    if (node->type == SEARCH_SCOUT) {
1,092,717    0    0   728,478      0    0         0    0    0   364,239 149,299  0   0      if (node->best_score < node->beta) {
        .    .    .         .      .    .         .    .    .         .       .  .   .        tt_hashtable_put(node->position.key, node->depth,
        .    .    .         .      .    .         .    .    .         .       .  .   .                         tt_adjust_score_for_hashtable(node->best_score, node->ply),
        .    .    .         .      .    .         .    .    .         .       .  .   .                         UPPER, 0);
        .    .    .         .      .    .         .    .    .         .       .  .   .      } else {
  215,864    0    0   215,864      0    0         0    0    0         0       0  0   0        tt_hashtable_put(node->position.key, node->depth,
  215,864    0    0   215,864      0    0         0    0    0         0       0  0   0                         tt_adjust_score_for_hashtable(node->best_score, node->ply),
        .    .    .         .      .    .         .    .    .         .       .  .   .                         LOWER, node->subpv[0]);
        .    .    .         .      .    .         .    .    .         .       .  .   .      }
      674    0    0         0      0    0         0    0    0       337     222  0   0    } else if (node->type == SEARCH_PV) {
    1,011    0    0       674      0    0         0    0    0       337      23  0   0      if (node->best_score <= node->orig_alpha) {
  890,388    0    0   296,796     24    0         0    0    0         0       0  0   0        tt_hashtable_put(node->position.key, node->depth,
  296,796    1    1   148,398      0    0   148,398    0    0         0       0  0   0            tt_adjust_score_for_hashtable(node->best_score, node->ply), UPPER, 0);
      628    0    0       314      0    0         0    0    0       314      97  0   0      } else if (node->best_score >= node->beta) {
1,296,200    0    0   432,276  2,144    0         0    0    0         0       0  0   0        tt_hashtable_put(node->position.key, node->depth,
  216,295    0    0       314      0    0   215,981    0    0         0       0  0   0            tt_adjust_score_for_hashtable(node->best_score, node->ply), LOWER, node->subpv[0]);
        .    .    .         .      .    .         .    .    .         .       .  .   .      } else {
    1,182    1    1       394      0    0         0    0    0         0       0  0   0        tt_hashtable_put(node->position.key, node->depth,
      197    0    0         0      0    0       197    0    0         0       0  0   0            tt_adjust_score_for_hashtable(node->best_score, node->ply), EXACT, node->subpv[0]);
        .    .    .         .      .    .         .    .    .         .       .  .   .      }
        .    .    .         .      .    .         .    .    .         .       .  .   .    }
1,093,728    0    0 1,093,728      0    0         0    0    0         0       0  0   0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /afs/athena.mit.edu/user/h/o/hongyis/project4/player/eval.c
--------------------------------------------------------------------------------
         Ir I1mr ILmr          Dr   D1mr DLmr         Dw   D1mw DLmw          Bc        Bcm Bi Bim 

-- line 23 ----------------------------------------
          .    .    .           .      .    .          .      .    .           .          .  .   .  int KAGGRESSIVE;
          .    .    .           .      .    .          .      .    .           .          .  .   .  int MOBILITY;
          .    .    .           .      .    .          .      .    .           .          .  .   .  int PAWNPIN;
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  char laser_map_black[ARR_SIZE];
          .    .    .           .      .    .          .      .    .           .          .  .   .  char laser_map_white[ARR_SIZE];
          .    .    .           .      .    .          .      .    .           .          .  .   .  
         76    2    2           0      0    0         66      9    7          65         17  0   0  void laser_map_init() {
          .    .    .           .      .    .          .      .    .           .          .  .   .    for (int i = 0; i < ARR_SIZE; ++i) {
          .    .    .           .      .    .          .      .    .           .          .  .   .      laser_map_black[i] = 4;   // Invalid square
          .    .    .           .      .    .          .      .    .           .          .  .   .      laser_map_white[i] = 4;   // Invalid square
          .    .    .           .      .    .          .      .    .           .          .  .   .    }
          2    0    0           2      0    0          0      0    0           0          0  0   0  }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  // Heuristics for static evaluation - described in the google doc
          .    .    .           .      .    .          .      .    .           .          .  .   .  // mentioned in the handout.
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  // PCENTRAL heuristic: Bonus for Pawn near center of board
          .    .    .           .      .    .          .      .    .           .          .  .   .  ev_score_t pcentral(fil_t f, rnk_t r) {
 17,305,460    0    0           0      0    0          0      0    0           0          0  0   0    double df = BOARD_WIDTH/2 - f - 1;
  8,652,730    0    0           0      0    0          0      0    0           0          0  0   0    if (df < 0)  df = f - BOARD_WIDTH/2;
 10,694,640    0    0           0      0    0          0      0    0           0          0  0   0    double dr = BOARD_WIDTH/2 - r - 1;
 42,762,610    3    1           0      0    0          0      0    0  10,694,640  5,992,314  0   0    if (dr < 0) dr = r - BOARD_WIDTH/2;
429,624,410    2    2 127,263,950      6    1 43,263,650      0    0           0          0  0   0    double bonus = 1 - sqrt(df * df + dr * dr) / (BOARD_WIDTH / sqrt(2));
 32,083,920    0    0  10,694,640      1    0          0      0    0           0          0  0   0    return PCENTRAL * bonus;
          .    .    .           .      .    .          .      .    .           .          .  .   .  }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  // returns true if c lies on or between a and b, which are not ordered
          .    .    .           .      .    .          .      .    .           .          .  .   .  bool between(int c, int a, int b) {
107,974,798    7    1  33,043,443      0    0          0      0    0  53,987,399  1,489,674  0   0    bool x = ((c >= a) && (c <= b)) || ((c <= a) && (c >= b));
          .    .    .           .      .    .          .      .    .           .          .  .   .    return x;
          .    .    .           .      .    .          .      .    .           .          .  .   .  }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  // PBETWEEN heuristic: Bonus for Pawn at (f, r) in rectangle defined by Kings at the corners
          .    .    .           .      .    .          .      .    .           .          .  .   .  ev_score_t pbetween(position_t *p, fil_t f, rnk_t r) {
          .    .    .           .      .    .          .      .    .           .          .  .   .    bool is_between =
 21,389,280    0    0  21,389,280 65,012    2          0      0    0           0          0  0   0        between(f, fil_of(p->kloc[WHITE]), fil_of(p->kloc[BLACK])) &&
 20,808,336   11    1  20,808,336 79,531    2          0      0    0           0          0  0   0        between(r, rnk_of(p->kloc[WHITE]), rnk_of(p->kloc[BLACK]));
 20,963,188    0    0  10,268,548    841    0          0      0    0           0          0  0   0    return is_between ? PBETWEEN : 0;
          .    .    .           .      .    .          .      .    .           .          .  .   .  }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  // KFACE heuristic: bonus (or penalty) for King facing toward the other King
          .    .    .           .      .    .          .      .    .           .          .  .   .  ev_score_t kface(position_t *p, fil_t f, rnk_t r) {
          .    .    .           .      .    .          .      .    .           .          .  .   .    square_t sq = square_of(f, r);
  1,730,546    0    0   1,730,546      0    0          0      0    0           0          0  0   0    piece_t x = p->board[sq];
          .    .    .           .      .    .          .      .    .           .          .  .   .    color_t c = color_of(x);
  3,461,092    0    0           0      0    0          0      0    0           0          0  0   0    square_t opp_sq = p->kloc[opp_color(c)];
  3,461,092    0    0   3,461,092  6,923    0          0      0    0           0          0  0   0    int delta_fil = fil_of(opp_sq) - f;
  3,461,092    0    0   1,730,546 11,314    0          0      0    0           0          0  0   0    int delta_rnk = rnk_of(opp_sq) - r;
          .    .    .           .      .    .          .      .    .           .          .  .   .    int bonus;
          .    .    .           .      .    .          .      .    .           .          .  .   .  
  5,203,406    0    0           0      0    0          0      0    0   2,601,703    135,821  0   0    switch (ori_of(x)) {
          .    .    .           .      .    .          .      .    .           .          .  .   .      case NN:
  2,497,395    0    0           0      0    0          0      0    0           0          0  0   0        bonus = delta_rnk;
          .    .    .           .      .    .          .      .    .           .          .  .   .        break;
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .      case EE:
          .    .    .           .      .    .          .      .    .           .          .  .   .        bonus = delta_fil;
          .    .    .           .      .    .          .      .    .           .          .  .   .        break;
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .      case SS:
  3,461,092    1    1           0      0    0          0      0    0           0          0  0   0        bonus = -delta_rnk;
          .    .    .           .      .    .          .      .    .           .          .  .   .        break;
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .      case WW:
  1,742,314    0    0           0      0    0          0      0    0           0          0  0   0        bonus = -delta_fil;
          .    .    .           .      .    .          .      .    .           .          .  .   .        break;
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .      default:
          .    .    .           .      .    .          .      .    .           .          .  .   .        bonus = 0;
          .    .    .           .      .    .          .      .    .           .          .  .   .        tbassert(false, "Illegal King orientation.\n");
          .    .    .           .      .    .          .      .    .           .          .  .   .    }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
 27,688,736    1    1   1,730,546      0    0          0      0    0           0          0  0   0    return (bonus * KFACE) / (abs(delta_rnk) + abs(delta_fil));
          .    .    .           .      .    .          .      .    .           .          .  .   .  }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  // KAGGRESSIVE heuristic: bonus for King with more space to back
          .    .    .           .      .    .          .      .    .           .          .  .   .  ev_score_t kaggressive(position_t *p, fil_t f, rnk_t r) {
          .    .    .           .      .    .          .      .    .           .          .  .   .    square_t sq = square_of(f, r);
          .    .    .           .      .    .          .      .    .           .          .  .   .    piece_t x = p->board[sq];
          .    .    .           .      .    .          .      .    .           .          .  .   .    color_t c = color_of(x);
          .    .    .           .      .    .          .      .    .           .          .  .   .    tbassert(ptype_of(x) == KING, "ptype_of(x) = %d\n", ptype_of(x));
-- line 108 ----------------------------------------
-- line 111 ----------------------------------------
          .    .    .           .      .    .          .      .    .           .          .  .   .    fil_t of = fil_of(opp_sq);
          .    .    .           .      .    .          .      .    .           .          .  .   .    rnk_t _or = (rnk_t) rnk_of(opp_sq);
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .    int delta_fil = of - f;
          .    .    .           .      .    .          .      .    .           .          .  .   .    int delta_rnk = _or - r;
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .    int bonus = 0;
          .    .    .           .      .    .          .      .    .           .          .  .   .  
 15,574,914    8    1           0      0    0          0      0    0   2,595,819      5,521  0   0    if (delta_fil >= 0 && delta_rnk >= 0) {
          .    .    .           .      .    .          .      .    .           .          .  .   .      bonus = (f + 1) * (r + 1);
  6,922,184    0    0           0      0    0          0      0    0   2,595,819         43  0   0    } else if (delta_fil <= 0 && delta_rnk >= 0) {
  1,730,546    0    0     865,273      0    0          0      0    0           0          0  0   0      bonus = (BOARD_WIDTH - f) * (r + 1);
  3,461,092    0    0           0      0    0          0      0    0   1,730,546        758  0   0    } else if (delta_fil <= 0 && delta_rnk <= 0) {
          .    .    .           .      .    .          .      .    .           .          .  .   .      bonus = (BOARD_WIDTH - f) * (BOARD_WIDTH - r);
  1,730,546    0    0           0      0    0          0      0    0     865,273          4  0   0    } else if (delta_fil >= 0 && delta_rnk <= 0) {
    865,273    0    0           0      0    0          0      0    0           0          0  0   0      bonus = (f + 1) * (BOARD_WIDTH - r);
          .    .    .           .      .    .          .      .    .           .          .  .   .    }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
 12,113,822    0    0   1,730,546     89    0          0      0    0           0          0  0   0    return (KAGGRESSIVE * bonus) / (BOARD_WIDTH * BOARD_WIDTH);
          .    .    .           .      .    .          .      .    .           .          .  .   .  }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  // Marks the path of the laser until it hits a piece or goes off the board. 
          .    .    .           .      .    .          .      .    .           .          .  .   .  // Returns the number of unpinned pawns.
          .    .    .           .      .    .          .      .    .           .          .  .   .  //
          .    .    .           .      .    .          .      .    .           .          .  .   .  // p : current board state
          .    .    .           .      .    .          .      .    .           .          .  .   .  // laser_map : end result will be stored here. Every square on the
          .    .    .           .      .    .          .      .    .           .          .  .   .  //             path of the laser is marked with mark_mask
          .    .    .           .      .    .          .      .    .           .          .  .   .  // c : color of king shooting laser
          .    .    .           .      .    .          .      .    .           .          .  .   .  // mark_mask: what each square is marked with
          .    .    .           .      .    .          .      .    .           .          .  .   .  int mark_laser_path(position_t *p, char *laser_map, color_t c,
  2,916,616    3    1           0      0    0  2,187,462      0    0           0          0  0   0                       char mark_mask) {
  2,095,123    0    0           0      0    0          0      0    0           0          0  0   0    int pinned_pawns = 0;
          .    .    .           .      .    .          .      .    .           .          .  .   .    uint8_t total_pawns;
          .    .    .           .      .    .          .      .    .           .          .  .   .    color_t color = opp_color(c);
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .    if (c == WHITE) { // opposing king pins our pawns 
  1,229,850    0    0   1,229,850      0    0          0      0    0           0          0  0   0      total_pawns = p->black_pawn_count;
          .    .    .           .      .    .          .      .    .           .          .  .   .    }
          .    .    .           .      .    .          .      .    .           .          .  .   .    else {
  3,918,008    1    1   1,229,850      0    0          0      0    0           0          0  0   0      total_pawns = p->white_pawn_count;
          .    .    .           .      .    .          .      .    .           .          .  .   .    }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .    // Fire laser, recording in laser_map
  2,459,700    0    0   1,229,850      0    0          0      0    0           0          0  0   0    square_t sq = p->kloc[c];
  1,229,850    0    0           0      0    0          0      0    0           0          0  0   0    int bdir = ori_of(p->board[sq]);
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .    tbassert(ptype_of(p->board[sq]) == KING,
          .    .    .           .      .    .          .      .    .           .          .  .   .             "ptype: %d\n", ptype_of(p->board[sq]));
  5,420,096   10    1   4,190,246      1    1          0      0    0           0          0  0   0    laser_map[sq] |= mark_mask;
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .    while (true) {
 45,067,360    1    1           0      0    0          0      0    0           0          0  0   0      sq += beam_of(bdir);
 90,134,720    0    0  22,533,680      1    0          0      0    0  22,533,680  1,666,808  0   0      if (color_of(p->board[sq]) == color &&
          .    .    .           .      .    .          .      .    .           .          .  .   .          ptype_of(p->board[sq]) == PAWN) {
 55,796,070    1    1           0      0    0          0      0    0           0          0  0   0          pinned_pawns += 1;
          .    .    .           .      .    .          .      .    .           .          .  .   .      }
 45,067,360    0    0  22,533,680      0    0          0      0    0           0          0  0   0      laser_map[sq] |= mark_mask;
          .    .    .           .      .    .          .      .    .           .          .  .   .      tbassert(sq < ARR_SIZE && sq >= 0, "sq: %d\n", sq);
          .    .    .           .      .    .          .      .    .           .          .  .   .  
153,529,346    0    0  22,533,680      0    0          0      0    0  65,497,833  2,825,508  0   0      switch (ptype_of(p->board[sq])) {
          .    .    .           .      .    .          .      .    .           .          .  .   .        case EMPTY:  // empty square
          .    .    .           .      .    .          .      .    .           .          .  .   .          break;
          .    .    .           .      .    .          .      .    .           .          .  .   .        case PAWN:  // Pawn
          .    .    .           .      .    .          .      .    .           .          .  .   .          bdir = reflect_of(bdir, ori_of(p->board[sq]));
  7,782,906    0    0   1,923,727      0    0          0      0    0   1,967,726     12,957  0   0          if (bdir < 0) {  // Hit back of Pawn
          .    .    .           .      .    .          .      .    .           .          .  .   .            return total_pawns - pinned_pawns;
          .    .    .           .      .    .          .      .    .           .          .  .   .          }
          .    .    .           .      .    .          .      .    .           .          .  .   .          break;
          .    .    .           .      .    .          .      .    .           .          .  .   .        case KING:  // King
          .    .    .           .      .    .          .      .    .           .          .  .   .            return total_pawns - pinned_pawns;
          .    .    .           .      .    .          .      .    .           .          .  .   .          break;
          .    .    .           .      .    .          .      .    .           .          .  .   .        case INVALID:  // Ran off edge of board
  2,095,123    0    0           0      0    0          0      0    0           0          0  0   0          return total_pawns - pinned_pawns;
          .    .    .           .      .    .          .      .    .           .          .  .   .          break;
          .    .    .           .      .    .          .      .    .           .          .  .   .        default:  // Shouldna happen, man!
          .    .    .           .      .    .          .      .    .           .          .  .   .          tbassert(false, "Not cool, man.  Not cool.\n");
          .    .    .           .      .    .          .      .    .           .          .  .   .          break;
          .    .    .           .      .    .          .      .    .           .          .  .   .      }
          .    .    .           .      .    .          .      .    .           .          .  .   .    }
  2,187,462    0    0   2,187,462      0    0          0      0    0           0          0  0   0  }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  // PAWNPIN Heuristic: count number of pawns that are pinned by the
          .    .    .           .      .    .          .      .    .           .          .  .   .  //   opposing king's laser --- and are thus immobile.
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  // int pawnpin(position_t *p, color_t color) {
          .    .    .           .      .    .          .      .    .           .          .  .   .  //   color_t c = opp_color(color);
          .    .    .           .      .    .          .      .    .           .          .  .   .    
-- line 198 ----------------------------------------
-- line 254 ----------------------------------------
          .    .    .           .      .    .          .      .    .           .          .  .   .    }
          .    .    .           .      .    .          .      .    .           .          .  .   .    int mobility = 0;
          .    .    .           .      .    .          .      .    .           .          .  .   .    square_t king_sq = p->kloc[color];
          .    .    .           .      .    .          .      .    .           .          .  .   .    tbassert(ptype_of(p->board[king_sq]) == KING,
          .    .    .           .      .    .          .      .    .           .          .  .   .             "ptype: %d\n", ptype_of(p->board[king_sq]));
          .    .    .           .      .    .          .      .    .           .          .  .   .    tbassert(color_of(p->board[king_sq]) == color,
          .    .    .           .      .    .          .      .    .           .          .  .   .             "color: %d\n", color_of(p->board[king_sq]));
          .    .    .           .      .    .          .      .    .           .          .  .   .  
  8,652,730    1    1   3,461,092      0    0          0      0    0           0          0  0   0    if (laser_map[king_sq] == 0) {
          .    .    .           .      .    .          .      .    .           .          .  .   .      mobility++;
          .    .    .           .      .    .          .      .    .           .          .  .   .    }
          .    .    .           .      .    .          .      .    .           .          .  .   .    for (int d = 0; d < 8; ++d) {
 13,844,368    1    1           0      0    0          0      0    0           0          0  0   0      square_t sq = king_sq + dir_of(d);
 36,341,466   12    3  11,248,549      0    0          0      0    0           0          0  0   0      if (laser_map[sq] == 0) {
 16,440,187    1    1           0      0    0          0      0    0           0          0  0   0        mobility++;
          .    .    .           .      .    .          .      .    .           .          .  .   .      }
          .    .    .           .      .    .          .      .    .           .          .  .   .    }
          .    .    .           .      .    .          .      .    .           .          .  .   .    return mobility;
          .    .    .           .      .    .          .      .    .           .          .  .   .  }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  // Harmonic-ish distance: 1/(|dx|+1) + 1/(|dy|+1)
          .    .    .           .      .    .          .      .    .           .          .  .   .  float h_dist(square_t a, square_t b) {
          .    .    .           .      .    .          .      .    .           .          .  .   .    //  printf("a = %d, FIL(a) = %d, RNK(a) = %d\n", a, FIL(a), RNK(a));
          .    .    .           .      .    .          .      .    .           .          .  .   .    //  printf("b = %d, FIL(b) = %d, RNK(b) = %d\n", b, FIL(b), RNK(b));
129,836,644    0    0  37,096,184 74,353    1          0      0    0           0          0  0   0    int delta_fil = abs(fil_of(a) - fil_of(b));
129,836,644    0    0  37,096,184 77,232    1          0      0    0           0          0  0   0    int delta_rnk = abs(rnk_of(a) - rnk_of(b));
224,307,650    3    3   1,730,546      0    0          0      0    0           0          0  0   0    float x = (1.0 / (delta_fil + 1)) + (1.0 / (delta_rnk + 1));
          .    .    .           .      .    .          .      .    .           .          .  .   .    //  printf("max_dist = %d\n\n", x);
          .    .    .           .      .    .          .      .    .           .          .  .   .    return x;
          .    .    .           .      .    .          .      .    .           .          .  .   .  }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  // H_SQUARES_ATTACKABLE heuristic: for shooting the enemy king
          .    .    .           .      .    .          .      .    .           .          .  .   .  int h_squares_attackable(position_t *p, color_t c) {
          .    .    .           .      .    .          .      .    .           .          .  .   .    char* laser_map;
          .    .    .           .      .    .          .      .    .           .          .  .   .    if (c == WHITE) {
          .    .    .           .      .    .          .      .    .           .          .  .   .      laser_map = laser_map_white;
          .    .    .           .      .    .          .      .    .           .          .  .   .    } else {
          .    .    .           .      .    .          .      .    .           .          .  .   .      laser_map = laser_map_black;
          .    .    .           .      .    .          .      .    .           .          .  .   .    }
  3,461,092    3    1   1,730,546      0    0          0      0    0           0          0  0   0    square_t o_king_sq = p->kloc[opp_color(c)];
          .    .    .           .      .    .          .      .    .           .          .  .   .    tbassert(ptype_of(p->board[o_king_sq]) == KING,
          .    .    .           .      .    .          .      .    .           .          .  .   .             "ptype: %d\n", ptype_of(p->board[o_king_sq]));
          .    .    .           .      .    .          .      .    .           .          .  .   .    tbassert(color_of(p->board[o_king_sq]) != c,
          .    .    .           .      .    .          .      .    .           .          .  .   .             "color: %d\n", color_of(p->board[o_king_sq]));
          .    .    .           .      .    .          .      .    .           .          .  .   .  
 20,766,552    0    0           0      0    0          0      0    0           0          0  0   0    float h_attackable = 0;
 34,610,920    0    0           0      0    0          0      0    0  17,305,460  1,628,596  0   0    for (fil_t f = 0; f < BOARD_WIDTH; f++) {
363,414,660    0    0           0      0    0          0      0    0 173,054,600 17,404,334  0   0      for (rnk_t r = 0; r < BOARD_WIDTH; r++) {
          .    .    .           .      .    .          .      .    .           .          .  .   .        square_t sq = square_of(f, r);
519,163,800    0    0 173,054,600      0    0          0      0    0 173,054,600 11,681,455  0   0        if (laser_map[sq] != 0) {
191,602,692    2    2           0      0    0          0      0    0           0          0  0   0          h_attackable += h_dist(sq, o_king_sq);
          .    .    .           .      .    .          .      .    .           .          .  .   .        }
          .    .    .           .      .    .          .      .    .           .          .  .   .      }
          .    .    .           .      .    .          .      .    .           .          .  .   .    }
  1,730,546    1    1           0      0    0          0      0    0           0          0  0   0    return h_attackable;
          .    .    .           .      .    .          .      .    .           .          .  .   .  }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  // Static evaluation.  Returns score
  8,652,730    1    1           0      0    0  6,922,184 22,779   16           0          0  0   0  score_t eval(position_t *p, bool verbose) {
          .    .    .           .      .    .          .      .    .           .          .  .   .    // seed rand_r with a value of 1, as per
          .    .    .           .      .    .          .      .    .           .          .  .   .    // http://linux.die.net/man/3/rand_r
          .    .    .           .      .    .          .      .    .           .          .  .   .    static __thread unsigned int seed = 1;
          .    .    .           .      .    .          .      .    .           .          .  .   .    // verbose = true: print out components of score
 41,533,104    1    1           0      0    0  2,595,819      0    0           0          0  0   0    ev_score_t score[2] = { 0, 0 };
          .    .    .           .      .    .          .      .    .           .          .  .   .    //  int corner[2][2] = { {INF, INF}, {INF, INF} };
          .    .    .           .      .    .          .      .    .           .          .  .   .    ev_score_t bonus;
          .    .    .           .      .    .          .      .    .           .          .  .   .    char buf[MAX_CHARS_IN_MOVE];
          .    .    .           .      .    .          .      .    .           .          .  .   .  
 17,305,460    0    0           0      0    0          0      0    0   8,652,730    858,528  0   0    for (fil_t f = 0; f < BOARD_WIDTH; f++) {
207,665,520    0    0   8,652,730      0    0          0      0    0  86,527,300  8,514,550  0   0      for (rnk_t r = 0; r < BOARD_WIDTH; r++) {
          .    .    .           .      .    .          .      .    .           .          .  .   .        square_t sq = square_of(f, r);
259,581,900    0    0  86,527,300      3    0          0      0    0           0          0  0   0        piece_t x = p->board[sq];
          .    .    .           .      .    .          .      .    .           .          .  .   .        color_t c = color_of(x);
173,054,600    0    0  86,527,300      0    0          0      0    0  86,527,300    330,837  0   0        if (verbose) {
          .    .    .           .      .    .          .      .    .           .          .  .   .          square_to_str(sq, buf, MAX_CHARS_IN_MOVE);
          .    .    .           .      .    .          .      .    .           .          .  .   .        }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
324,719,920    1    1           0      0    0          0      0    0 162,359,960 13,758,117  0   0        switch (ptype_of(x)) {
          .    .    .           .      .    .          .      .    .           .          .  .   .          case EMPTY:
          .    .    .           .      .    .          .      .    .           .          .  .   .            break;
          .    .    .           .      .    .          .      .    .           .          .  .   .          case PAWN:
          .    .    .           .      .    .          .      .    .           .          .  .   .            // MATERIAL heuristic: Bonus for each Pawn
          .    .    .           .      .    .          .      .    .           .          .  .   .            bonus = PAWN_EV_VALUE;
          .    .    .           .      .    .          .      .    .           .          .  .   .            // if (verbose) {
          .    .    .           .      .    .          .      .    .           .          .  .   .            //  printf("MATERIAL bonus %d for %s Pawn on %s\n", bonus, color_to_str(c), buf);
          .    .    .           .      .    .          .      .    .           .          .  .   .            // }
 32,083,920    6    1  10,694,640      0    0          0      0    0           0          0  0   0            score[c] += bonus;
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .            // PBETWEEN heuristic
          .    .    .           .      .    .          .      .    .           .          .  .   .            bonus = pbetween(p, f, r);
          .    .    .           .      .    .          .      .    .           .          .  .   .            // if (verbose) {
          .    .    .           .      .    .          .      .    .           .          .  .   .            //   printf("PBETWEEN bonus %d for %s Pawn on %s\n", bonus, color_to_str(c), buf);
          .    .    .           .      .    .          .      .    .           .          .  .   .            // }
 32,083,920    0    0           0      0    0          0      0    0           0          0  0   0            score[c] += bonus;
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .            // PCENTRAL heuristic
          .    .    .           .      .    .          .      .    .           .          .  .   .            bonus = pcentral(f, r);
          .    .    .           .      .    .          .      .    .           .          .  .   .            // if (verbose) {
          .    .    .           .      .    .          .      .    .           .          .  .   .            //   printf("PCENTRAL bonus %d for %s Pawn on %s\n", bonus, color_to_str(c), buf);
          .    .    .           .      .    .          .      .    .           .          .  .   .           //  }
 21,389,280    0    0           0      0    0 10,694,640      0    0           0          0  0   0            score[c] += bonus;
 10,694,640    0    0           0      0    0          0      0    0           0          0  0   0            break;
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .          case KING:
          .    .    .           .      .    .          .      .    .           .          .  .   .            // KFACE heuristic
          .    .    .           .      .    .          .      .    .           .          .  .   .            bonus = kface(p, f, r);
          .    .    .           .      .    .          .      .    .           .          .  .   .            // if (verbose) {
          .    .    .           .      .    .          .      .    .           .          .  .   .            //   printf("KFACE bonus %d for %s King on %s\n", bonus,
          .    .    .           .      .    .          .      .    .           .          .  .   .            //          color_to_str(c), buf);
          .    .    .           .      .    .          .      .    .           .          .  .   .            // }
  5,191,638    0    0   1,730,546      0    0          0      0    0           0          0  0   0            score[c] += bonus;
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .            // KAGGRESSIVE heuristic
          .    .    .           .      .    .          .      .    .           .          .  .   .            bonus = kaggressive(p, f, r);
          .    .    .           .      .    .          .      .    .           .          .  .   .            // if (verbose) {
          .    .    .           .      .    .          .      .    .           .          .  .   .            //   printf("KAGGRESSIVE bonus %d for %s King on %s\n", bonus, color_to_str(c), buf);
          .    .    .           .      .    .          .      .    .           .          .  .   .           //  }
436,097,592    1    1 173,054,600      0    0  1,730,546      0    0           0          0  0   0            score[c] += bonus;
          .    .    .           .      .    .          .      .    .           .          .  .   .            break;
          .    .    .           .      .    .          .      .    .           .          .  .   .          case INVALID:
          .    .    .           .      .    .          .      .    .           .          .  .   .            break;
          .    .    .           .      .    .          .      .    .           .          .  .   .          default:
          .    .    .           .      .    .          .      .    .           .          .  .   .            tbassert(false, "Jose says: no way!\n");   // No way, Jose!
          .    .    .           .      .    .          .      .    .           .          .  .   .        }
 86,527,300    0    0           0      0    0 86,527,300 36,135    0           0          0  0   0        laser_map_black[sq] = 0;
 86,527,300    1    1           0      0    0 86,527,300 84,382    0           0          0  0   0        laser_map_white[sq] = 0;
          .    .    .           .      .    .          .      .    .           .          .  .   .      }
          .    .    .           .      .    .          .      .    .           .          .  .   .    }
          .    .    .           .      .    .          .      .    .           .          .  .   .     
          .    .    .           .      .    .          .      .    .           .          .  .   .    int black_pawns_unpinned = mark_laser_path(p, laser_map_white, WHITE, 1);  // 1 = path of laser with no moves
          .    .    .           .      .    .          .      .    .           .          .  .   .    
  1,730,546    0    0     865,273      0    0          0      0    0           0          0  0   0    ev_score_t w_hattackable = HATTACK * h_squares_attackable(p, WHITE);
    865,273    0    0     865,273      0    0          0      0    0           0          0  0   0    score[WHITE] += w_hattackable;
          .    .    .           .      .    .          .      .    .           .          .  .   .    // if (verbose) {
          .    .    .           .      .    .          .      .    .           .          .  .   .    //   printf("HATTACK bonus %d for White\n", w_hattackable);
          .    .    .           .      .    .          .      .    .           .          .  .   .    // }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .    // PAWNPIN Heuristic --- is a pawn immobilized by the enemy laser.
  1,730,546    0    0     865,273      0    0          0      0    0           0          0  0   0    int b_pawnpin = PAWNPIN * black_pawns_unpinned;
  1,730,546    0    0   1,730,546      0    0          0      0    0           0          0  0   0    score[BLACK] += b_pawnpin;
          .    .    .           .      .    .          .      .    .           .          .  .   .  
  2,595,819    0    0     865,273      0    0          0      0    0           0          0  0   0    int b_mobility = MOBILITY * mobility(p, BLACK);
    865,273    0    0           0      0    0          0      0    0           0          0  0   0    score[BLACK] += b_mobility;
          .    .    .           .      .    .          .      .    .           .          .  .   .    // if (verbose) {
          .    .    .           .      .    .          .      .    .           .          .  .   .    //   printf("MOBILITY bonus %d for Black\n", b_mobility);
          .    .    .           .      .    .          .      .    .           .          .  .   .    // }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .    int white_pawns_unpinned = mark_laser_path(p, laser_map_black, BLACK, 1);  // 1 = path of laser with no moves
          .    .    .           .      .    .          .      .    .           .          .  .   .    
    865,273    1    1           0      0    0          0      0    0           0          0  0   0    ev_score_t b_hattackable = HATTACK * h_squares_attackable(p, BLACK);
    865,273    0    0           0      0    0          0      0    0           0          0  0   0    score[BLACK] += b_hattackable;
          .    .    .           .      .    .          .      .    .           .          .  .   .    // if (verbose) {
          .    .    .           .      .    .          .      .    .           .          .  .   .    //   printf("HATTACK bonus %d for Black\n", b_hattackable);
          .    .    .           .      .    .          .      .    .           .          .  .   .    // }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
    865,273    0    0           0      0    0          0      0    0           0          0  0   0    int w_mobility = MOBILITY * mobility(p, WHITE);
    865,273    0    0           0      0    0          0      0    0           0          0  0   0    score[WHITE] += w_mobility;
          .    .    .           .      .    .          .      .    .           .          .  .   .    // if (verbose) {
          .    .    .           .      .    .          .      .    .           .          .  .   .    //   printf("MOBILITY bonus %d for White\n", w_mobility);
          .    .    .           .      .    .          .      .    .           .          .  .   .    // }
    865,273    0    0           0      0    0          0      0    0           0          0  0   0    int w_pawnpin = PAWNPIN * white_pawns_unpinned;
    865,273    0    0           0      0    0          0      0    0           0          0  0   0    score[WHITE] += w_pawnpin;
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .    // score from WHITE point of view
    865,273    0    0           0      0    0          0      0    0           0          0  0   0    ev_score_t tot = score[WHITE] - score[BLACK];
          .    .    .           .      .    .          .      .    .           .          .  .   .  
  2,595,819    0    0     865,273      0    0          0      0    0     865,273          0  0   0    if (RANDOMIZE) {
          .    .    .           .      .    .          .      .    .           .          .  .   .      ev_score_t  z = rand_r(&seed) % (RANDOMIZE*2+1);
          .    .    .           .      .    .          .      .    .           .          .  .   .      tot = tot + z - RANDOMIZE;
          .    .    .           .      .    .          .      .    .           .          .  .   .    }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
          .    .    .           .      .    .          .      .    .           .          .  .   .    if (color_to_move_of(p) == BLACK) {
  3,461,092    0    0     865,273      0    0          0      0    0           0          0  0   0      tot = -tot;
          .    .    .           .      .    .          .      .    .           .          .  .   .    }
          .    .    .           .      .    .          .      .    .           .          .  .   .  
  5,191,638    0    0           0      0    0          0      0    0           0          0  0   0    return tot / EV_SCORE_RATIO;
  7,787,457    0    0   6,056,911      0    0          0      0    0           0          0  0   0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /afs/athena.mit.edu/user/h/o/hongyis/project4/player/move_gen.c
--------------------------------------------------------------------------------
         Ir I1mr ILmr          Dr      D1mr DLmr          Dw    D1mw  DLmw          Bc        Bcm Bi Bim 

-- line 43 ----------------------------------------
          .    .    .           .         .    .           .       .     .           .          .  .   .  // Board, squares
          .    .    .           .         .    .           .       .     .           .          .  .   .  // -----------------------------------------------------------------------------
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  static uint64_t   zob[ARR_SIZE][1<<PIECE_SIZE];
          .    .    .           .         .    .           .       .     .           .          .  .   .  static uint64_t   zob_color;
          .    .    .           .         .    .           .       .     .           .          .  .   .  uint64_t myrand();
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  // Zobrist hashing
          4    1    1           0         0    0           2       0     0           0          0  0   0  uint64_t compute_zob_key(position_t *p) {
          2    0    0           0         0    0           0       0     0           0          0  0   0    uint64_t key = 0;
         20    0    0           0         0    0           0       0     0          10         10  0   0    for (fil_t f = 0; f < BOARD_WIDTH; f++) {
          .    .    .           .         .    .           .       .     .           .          .  .   .      for (rnk_t r = 0; r < BOARD_WIDTH; r++) {
          .    .    .           .         .    .           .       .     .           .          .  .   .        square_t sq = square_of(f, r);
        630    5    5         200       100    0           0       0     0           0          0  0   0        key ^= zob[sq][p->board[sq]];
          .    .    .           .         .    .           .       .     .           .          .  .   .      }
          .    .    .           .         .    .           .       .     .           .          .  .   .    }
          .    .    .           .         .    .           .       .     .           .          .  .   .    if (color_to_move_of(p) == BLACK)
          4    0    0           2         1    0           0       0     0           0          0  0   0      key ^= zob_color;
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    return key;
          2    0    0           2         0    0           0       0     0           0          0  0   0  }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
        519    1    1           0         0    0           4       0     0           0          0  0   0  void init_zob() {
        512    1    1           0         0    0           0       0     0         256          3  0   0    for (int i = 0; i < ARR_SIZE; i++) {
     16,640    0    0           0         0    0           0       0     0       8,192        259  0   0      for (int j = 0; j < (1 << PIECE_SIZE); j++) {
     32,768    0    0           0         0    0      16,384   1,025 1,025           0          0  0   0        zob[i][j] = myrand();
          .    .    .           .         .    .           .       .     .           .          .  .   .      }
          .    .    .           .         .    .           .       .     .           .          .  .   .    }
          3    0    0           0         0    0           2       1     0           0          0  0   0    zob_color = myrand();
          4    0    0           4         0    0           0       0     0           0          0  0   0  }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  // converts a square to string notation, returns number of characters printed
          .    .    .           .         .    .           .       .     .           .          .  .   .  int square_to_str(square_t sq, char *buf, size_t bufsize) {
          .    .    .           .         .    .           .       .     .           .          .  .   .    fil_t f = fil_of(sq);
          .    .    .           .         .    .           .       .     .           .          .  .   .    rnk_t r = rnk_of(sq);
        108    0    0           0         0    0           0       0     0          54          2  0   0    if (f >= 0) {
        522    0    0          78         0    0         117       0     0           0          0  0   0      return snprintf(buf, bufsize, "%c%d", 'a'+ f, r);
          .    .    .           .         .    .           .       .     .           .          .  .   .    } else  {
         45    2    1           0         0    0           0       0     0           0          0  0   0      return snprintf(buf, bufsize, "%c%d", 'z' + f + 1, r);
          .    .    .           .         .    .           .       .     .           .          .  .   .    }
          .    .    .           .         .    .           .       .     .           .          .  .   .  }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  // converts a move to string notation for FEN
        507    1    1           0         0    0         312       0     0           0          0  0   0  void move_to_str(move_t mv, char *buf, size_t bufsize) {
          .    .    .           .         .    .           .       .     .           .          .  .   .    square_t f = from_square(mv);  // from-square
          .    .    .           .         .    .           .       .     .           .          .  .   .    square_t t = to_square(mv);    // to-square
          .    .    .           .         .    .           .       .     .           .          .  .   .    rot_t r = rot_of(mv);          // rotation
          .    .    .           .         .    .           .       .     .           .          .  .   .    const char *orig_buf = buf;
          .    .    .           .         .    .           .       .     .           .          .  .   .  
         78    9    1           0         0    0           0       0     0           0          0  0   0    buf += square_to_str(f, buf, bufsize);
         78    0    0           0         0    0           0       0     0          39         17  0   0    if (f != t) {
         30    0    0           0         0    0           0       0     0           0          0  0   0      buf += square_to_str(t, buf, bufsize - (buf - orig_buf));
          .    .    .           .         .    .           .       .     .           .          .  .   .    } else {
        136    0    0           0         0    0           0       0     0          68         15  0   0      switch (r) {
          .    .    .           .         .    .           .       .     .           .          .  .   .        case NONE:
          .    .    .           .         .    .           .       .     .           .          .  .   .          buf += square_to_str(t, buf, bufsize - (buf - orig_buf));
          .    .    .           .         .    .           .       .     .           .          .  .   .          break;
          .    .    .           .         .    .           .       .     .           .          .  .   .        case RIGHT:
         42    0    0           0         0    0           0       0     0           0          0  0   0          buf += snprintf(buf, bufsize - (buf - orig_buf), "R");
          .    .    .           .         .    .           .       .     .           .          .  .   .          break;
          .    .    .           .         .    .           .       .     .           .          .  .   .        case UTURN:
         49    1    1           0         0    0           0       0     0           0          0  0   0          buf += snprintf(buf, bufsize - (buf - orig_buf), "U");
          .    .    .           .         .    .           .       .     .           .          .  .   .          break;
          .    .    .           .         .    .           .       .     .           .          .  .   .        case LEFT:
         52    0    0           0         0    0           0       0     0           0          0  0   0          buf += snprintf(buf, bufsize - (buf - orig_buf), "L");
          .    .    .           .         .    .           .       .     .           .          .  .   .          break;
          .    .    .           .         .    .           .       .     .           .          .  .   .        default:
          .    .    .           .         .    .           .       .     .           .          .  .   .          tbassert(false, "Whoa, now.  Whoa, I say.\n");  // Bad, bad, bad
          .    .    .           .         .    .           .       .     .           .          .  .   .          break;
          .    .    .           .         .    .           .       .     .           .          .  .   .      }
          .    .    .           .         .    .           .       .     .           .          .  .   .    }
        273    0    0         234         0    0           0       0     0           0          0  0   0  }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  // Generate all moves from position p.  Returns number of moves.
          .    .    .           .         .    .           .       .     .           .          .  .   .  // strict currently ignored
          .    .    .           .         .    .           .       .     .           .          .  .   .  int generate_all(position_t *p, sortable_move_t *sortable_move_list,
  4,739,501    3    1           0         0    0   2,916,616 149,619    26           0          0  0   0                   bool strict) {
          .    .    .           .         .    .           .       .     .           .          .  .   .    color_t color_to_move = color_to_move_of(p);
          .    .    .           .         .    .           .       .     .           .          .  .   .    // Make sure that the enemy_laser map is marked
          .    .    .           .         .    .           .       .     .           .          .  .   .    char laser_map[ARR_SIZE];
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    for (int i = 0; i < ARR_SIZE; ++i) {
          .    .    .           .         .    .           .       .     .           .          .  .   .      laser_map[i] = 4;   // Invalid square
          .    .    .           .         .    .           .       .     .           .          .  .   .    }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    for (fil_t f = 0; f < BOARD_WIDTH; ++f) {
          .    .    .           .         .    .           .       .     .           .          .  .   .      for (rnk_t r = 0; r < BOARD_WIDTH; ++r) {
 36,457,700   10   10           0         0    0  36,457,700       0     0           0          0  0   0        laser_map[square_of(f, r)] = 0;
          .    .    .           .         .    .           .       .     .           .          .  .   .      }
          .    .    .           .         .    .           .       .     .           .          .  .   .    }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    // 1 = path of laser with no moves
  1,458,308    1    1           0         0    0     364,577       0     0           0          0  0   0    mark_laser_path(p, laser_map, opp_color(color_to_move), 1);
          .    .    .           .         .    .           .       .     .           .          .  .   .  
 51,769,934    1    1           0         0    0   7,291,540       0     0           0          0  0   0    int move_count = 0;
          .    .    .           .         .    .           .       .     .           .          .  .   .  
  7,291,540    0    0           0         0    0           0       0     0   3,645,770    400,196  0   0    for (fil_t f = 0; f < BOARD_WIDTH; f++) {
 72,915,400    0    0  36,457,700         0    0           0       0     0  36,457,700  3,419,950  0   0      for (rnk_t r = 0; r < BOARD_WIDTH; r++) {
          .    .    .           .         .    .           .       .     .           .          .  .   .        square_t  sq = square_of(f, r);
109,373,100    0    0  36,457,700         0    0           0       0     0           0          0  0   0        piece_t x = p->board[sq];
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .        ptype_t typ = ptype_of(x);
          .    .    .           .         .    .           .       .     .           .          .  .   .        color_t color = color_of(x);
          .    .    .           .         .    .           .       .     .           .          .  .   .  
136,902,734    0    0           0         0    0           0       0     0  68,451,367  5,224,312  0   0        switch (typ) {
          .    .    .           .         .    .           .       .     .           .          .  .   .          case EMPTY:
          .    .    .           .         .    .           .       .     .           .          .  .   .            break;
          .    .    .           .         .    .           .       .     .           .          .  .   .          case PAWN:
  8,928,066    0    0   4,464,033         0    0           0       0     0   4,464,033    397,813  0   0            if (laser_map[sq] == 1) continue;  // Piece is pinned down by laser.
          .    .    .           .         .    .           .       .     .           .          .  .   .          case KING:
287,499,319    1    1  41,290,569         0    0   5,028,818       0     0   7,347,278  1,653,586  0   0            if (color != color_to_move) {  // Wrong color
          .    .    .           .         .    .           .       .     .           .          .  .   .              break;
          .    .    .           .         .    .           .       .     .           .          .  .   .            }
          .    .    .           .         .    .           .       .     .           .          .  .   .            // directions
 47,296,304    1    1   6,449,496         0    0   4,299,664       0     0  17,198,656  1,582,816  0   0            for (int d = 0; d < 8; d++) {
 37,678,505    2    2  17,198,656         1    1           0       0     0           0          0  0   0              int dest = sq + dir_of(d);
          .    .    .           .         .    .           .       .     .           .          .  .   .              // Skip moves into invalid squares, squares occupied by
          .    .    .           .         .    .           .       .     .           .          .  .   .              // kings, nonempty squares if x is a king, and squares with
          .    .    .           .         .    .           .       .     .           .          .  .   .              // pawns of matching color
 89,274,473   10    2  17,198,656         2    0           0       0     0  17,563,233  1,698,608  0   0              if (ptype_of(p->board[dest]) == INVALID ||
          .    .    .           .         .    .           .       .     .           .          .  .   .                  ptype_of(p->board[dest]) == KING ||
  6,252,165   12    2   2,916,616         0    0     364,577       0     0   2,916,616     54,978  0   0                  (typ == KING && ptype_of(p->board[dest]) != EMPTY) ||
 36,903,124    0    0   2,180,303         0    0           0       0     0  17,378,216  2,272,645  0   0                  (typ == PAWN && ptype_of(p->board[dest]) == PAWN &&
          .    .    .           .         .    .           .       .     .           .          .  .   .                   color == color_of(p->board[dest]))) {
          .    .    .           .         .    .           .       .     .           .          .  .   .                continue;    // illegal square
          .    .    .           .         .    .           .       .     .           .          .  .   .              }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .              WHEN_DEBUG_VERBOSE(char buf[MAX_CHARS_IN_MOVE]);
          .    .    .           .         .    .           .       .     .           .          .  .   .              WHEN_DEBUG_VERBOSE({
          .    .    .           .         .    .           .       .     .           .          .  .   .                  move_to_str(move_of(typ, (rot_t) 0, sq, dest), buf, MAX_CHARS_IN_MOVE);
          .    .    .           .         .    .           .       .     .           .          .  .   .                  DEBUG_LOG(1, "Before: %s ", buf);
          .    .    .           .         .    .           .       .     .           .          .  .   .                });
          .    .    .           .         .    .           .       .     .           .          .  .   .              tbassert(move_count < MAX_NUM_MOVES, "move_count: %d\n", move_count);
 75,030,248    1    1  14,706,489         0    0  14,457,898 178,722    72           0          0  0   0              sortable_move_list[move_count++] = move_of(typ, (rot_t) 0, sq, dest);
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .              WHEN_DEBUG_VERBOSE({
          .    .    .           .         .    .           .       .     .           .          .  .   .                  move_to_str(get_move(sortable_move_list[move_count-1]), buf, MAX_CHARS_IN_MOVE);
          .    .    .           .         .    .           .       .     .           .          .  .   .                  DEBUG_LOG(1, "After: %s\n", buf);
          .    .    .           .         .    .           .       .     .           .          .  .   .                });
          .    .    .           .         .    .           .       .     .           .          .  .   .            }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .            // rotations - three directions possible
          .    .    .           .         .    .           .       .     .           .          .  .   .            for (int rot = 1; rot < 4; ++rot) {
          .    .    .           .         .    .           .       .     .           .          .  .   .              tbassert(move_count < MAX_NUM_MOVES, "move_count: %d\n", move_count);
 22,629,681   11    2   7,543,227         0    0   7,543,227  83,534    51           0          0  0   0              sortable_move_list[move_count++] = move_of(typ, (rot_t) rot, sq, sq);
          .    .    .           .         .    .           .       .     .           .          .  .   .            }
  5,028,818    0    0           0         0    0           0       0     0   2,514,409     86,749  0   0            if (typ == KING) {  // Also generate null move
          .    .    .           .         .    .           .       .     .           .          .  .   .              tbassert(move_count < MAX_NUM_MOVES, "move_count: %d\n", move_count);
  8,749,848    1    1   4,010,347         0    0     364,577   6,875     2           0          0  0   0              sortable_move_list[move_count++] = move_of(typ, (rot_t) 0, sq, sq);
          .    .    .           .         .    .           .       .     .           .          .  .   .            }
          .    .    .           .         .    .           .       .     .           .          .  .   .            break;
          .    .    .           .         .    .           .       .     .           .          .  .   .          case INVALID:
          .    .    .           .         .    .           .       .     .           .          .  .   .          default:
          .    .    .           .         .    .           .       .     .           .          .  .   .            tbassert(false, "Bogus, man.\n");  // Couldn't BE more bogus!
          .    .    .           .         .    .           .       .     .           .          .  .   .        }
          .    .    .           .         .    .           .       .     .           .          .  .   .      }
          .    .    .           .         .    .           .       .     .           .          .  .   .    }
-- line 203 ----------------------------------------
-- line 208 ----------------------------------------
          .    .    .           .         .    .           .       .     .           .          .  .   .          char buf[MAX_CHARS_IN_MOVE];
          .    .    .           .         .    .           .       .     .           .          .  .   .          move_to_str(get_move(sortable_move_list[i]), buf, MAX_CHARS_IN_MOVE);
          .    .    .           .         .    .           .       .     .           .          .  .   .          DEBUG_LOG(1, "%s ", buf);
          .    .    .           .         .    .           .       .     .           .          .  .   .        }
          .    .    .           .         .    .           .       .     .           .          .  .   .        DEBUG_LOG(1, "\n");
          .    .    .           .         .    .           .       .     .           .          .  .   .      });
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    return move_count;
  5,431,025   10    0   2,552,039         0    0           0       0     0           0          0  0   0  }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  square_t low_level_make_move(position_t *old, position_t *p, move_t mv) {
          .    .    .           .         .    .           .       .     .           .          .  .   .    tbassert(mv != 0, "mv was zero.\n");
          .    .    .           .         .    .           .       .     .           .          .  .   .  
 12,270,246    0    0           0         0    0   6,107,553       0     0           0          0  0   0    square_t stomped_dst_sq = 0;
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    WHEN_DEBUG_VERBOSE(char buf[MAX_CHARS_IN_MOVE]);
          .    .    .           .         .    .           .       .     .           .          .  .   .    WHEN_DEBUG_VERBOSE({
          .    .    .           .         .    .           .       .     .           .          .  .   .        move_to_str(mv, buf, MAX_CHARS_IN_MOVE);
          .    .    .           .         .    .           .       .     .           .          .  .   .        DEBUG_LOG(1, "low_level_make_move: %s\n", buf);
          .    .    .           .         .    .           .       .     .           .          .  .   .      });
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    tbassert(old->key == compute_zob_key(old),
-- line 229 ----------------------------------------
-- line 259 ----------------------------------------
          .    .    .           .         .    .           .       .     .           .          .  .   .            DEBUG_LOG(1, "rot: L\n");
          .    .    .           .         .    .           .       .     .           .          .  .   .            break;
          .    .    .           .         .    .           .       .     .           .          .  .   .          default:
          .    .    .           .         .    .           .       .     .           .          .  .   .            tbassert(false, "Not like a boss at all.\n");  // Bad, bad, bad
          .    .    .           .         .    .           .       .     .           .          .  .   .            break;
          .    .    .           .         .    .           .       .     .           .          .  .   .        }
          .    .    .           .         .    .           .       .     .           .          .  .   .      });
          .    .    .           .         .    .           .       .     .           .          .  .   .  
375,107,960    0    0 337,597,164    90,547    0 337,597,164 100,282    94 337,597,164  9,377,761  0   0    *p = *old;
          .    .    .           .         .    .           .       .     .           .          .  .   .  
  9,377,699    0    0           0         0    0   9,377,699       0     0           0          0  0   0    p->history = old;
  9,377,699    0    0           0         0    0   9,377,699       0     0           0          0  0   0    p->last_move = mv;
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    tbassert(from_sq < ARR_SIZE && from_sq > 0, "from_sq: %d\n", from_sq);
          .    .    .           .         .    .           .       .     .           .          .  .   .    tbassert(p->board[from_sq] < (1 << PIECE_SIZE) && p->board[from_sq] >= 0,
          .    .    .           .         .    .           .       .     .           .          .  .   .             "p->board[from_sq]: %d\n", p->board[from_sq]);
          .    .    .           .         .    .           .       .     .           .          .  .   .    tbassert(to_sq < ARR_SIZE && to_sq > 0, "to_sq: %d\n", to_sq);
          .    .    .           .         .    .           .       .     .           .          .  .   .    tbassert(p->board[to_sq] < (1 << PIECE_SIZE) && p->board[to_sq] >= 0,
          .    .    .           .         .    .           .       .     .           .          .  .   .             "p->board[to_sq]: %d\n", p->board[to_sq]);
          .    .    .           .         .    .           .       .     .           .          .  .   .  
 37,510,796    0    0  18,755,398         9    0   9,377,699       0     0           0          0  0   0    p->key ^= zob_color;   // swap color to move
          .    .    .           .         .    .           .       .     .           .          .  .   .  
 18,755,398    0    0   9,377,699         0    0           0       0     0           0          0  0   0    piece_t from_piece = p->board[from_sq];
 18,755,398    1    1   9,377,699         0    0           0       0     0           0          0  0   0    piece_t to_piece = p->board[to_sq];
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    // Pieces block each other, unless a pawn is stomping an enemy pawn
          .    .    .           .         .    .           .       .     .           .          .  .   .    tbassert(EMPTY == ptype_of(to_piece) ||
          .    .    .           .         .    .           .       .     .           .          .  .   .             from_sq == to_sq ||
          .    .    .           .         .    .           .       .     .           .          .  .   .             (PAWN == ptype_of(from_piece) &&
          .    .    .           .         .    .           .       .     .           .          .  .   .              PAWN == ptype_of(to_piece) &&
          .    .    .           .         .    .           .       .     .           .          .  .   .              color_of(to_piece) == opp_color(color_of(from_piece))),
          .    .    .           .         .    .           .       .     .           .          .  .   .             "from-type: %d, to-type: %d, from-sq: %d, to-sq: %d, from-color: %d, to-color: %d\n",
          .    .    .           .         .    .           .       .     .           .          .  .   .             ptype_of(from_piece), ptype_of(to_piece),
          .    .    .           .         .    .           .       .     .           .          .  .   .             from_sq, to_sq,
          .    .    .           .         .    .           .       .     .           .          .  .   .             color_of(from_piece), color_of(to_piece));
          .    .    .           .         .    .           .       .     .           .          .  .   .  
 18,755,398    0    0           0         0    0           0       0     0   9,377,699  1,936,721  0   0    if (to_sq != from_sq) {  // move, not rotation
 23,166,180    2    0           0         0    0           0       0     0  11,583,090    700,644  0   0      if (PAWN == ptype_of(from_piece) &&
          .    .    .           .         .    .           .       .     .           .          .  .   .          PAWN == ptype_of(to_piece) &&
          .    .    .           .         .    .           .       .     .           .          .  .   .          color_of(to_piece) == opp_color(color_of(from_piece))) {
          .    .    .           .         .    .           .       .     .           .          .  .   .        // We're stomping a piece.  Return the destination of the
          .    .    .           .         .    .           .       .     .           .          .  .   .        // stomped piece.  Let the caller remove the piece from the
          .    .    .           .         .    .           .       .     .           .          .  .   .        // board.
          .    .    .           .         .    .           .       .     .           .          .  .   .        stomped_dst_sq = from_sq;
          .    .    .           .         .    .           .       .     .           .          .  .   .      }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .      // Hash key updates
 54,802,557    1    1   6,089,173   300,908    0  18,267,519       0     0           0          0  0   0      p->key ^= zob[from_sq][from_piece];  // remove from_piece from from_sq
 48,713,384    0    0   6,089,173 2,819,626    0  12,178,346       0     0           0          0  0   0      p->key ^= zob[to_sq][to_piece];  // remove to_piece from to_sq
          .    .    .           .         .    .           .       .     .           .          .  .   .  
  6,089,173    0    0           0         0    0   6,089,173       0     0           0          0  0   0      p->board[to_sq] = from_piece;  // swap from_piece and to_piece on board
  6,089,173    0    0           0         0    0   6,089,173       0     0           0          0  0   0      p->board[from_sq] = to_piece;
          .    .    .           .         .    .           .       .     .           .          .  .   .  
 24,356,692    1    1  18,267,519 2,603,531    0   6,089,173       0     0           0          0  0   0      p->key ^= zob[to_sq][from_piece];  // place from_piece in to_sq
 18,267,519    0    0  12,178,346   477,588    0   6,089,173       0     0           0          0  0   0      p->key ^= zob[from_sq][to_piece];  // place to_piece in from_sq
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .      // Update King locations if necessary
 12,178,346    0    0           0         0    0           0       0     0   6,089,173          4  0   0      if (ptype_of(from_piece) == KING) {
  2,381,024    0    0           0         0    0     595,256       0     0           0          0  0   0        p->kloc[color_of(from_piece)] = to_sq;
          .    .    .           .         .    .           .       .     .           .          .  .   .      }
 12,178,346    0    0           0         0    0           0       0     0   6,089,173         16  0   0      if (ptype_of(to_piece) == KING) {
          .    .    .           .         .    .           .       .     .           .          .  .   .        p->kloc[color_of(to_piece)] = from_sq;
          .    .    .           .         .    .           .       .     .           .          .  .   .      }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    } else {  // rotation
          .    .    .           .         .    .           .       .     .           .          .  .   .      // remove from_piece from from_sq in hash
 19,731,156    2    2   3,288,526   154,139    0   3,288,526       0     0           0          0  0   0      p->key ^= zob[from_sq][from_piece];
  3,288,526    0    0           0         0    0           0       0     0           0          0  0   0      set_ori(&from_piece, rot + ori_of(from_piece));  // rotate from_piece
  3,288,526    0    0           0         0    0   3,288,526       0     0           0          0  0   0      p->board[from_sq] = from_piece;  // place rotated piece on board
 13,154,104    0    0   3,288,526         0    0   3,288,526       0     0           0          0  0   0      p->key ^= zob[from_sq][from_piece];              // ... and in hash
          .    .    .           .         .    .           .       .     .           .          .  .   .    }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    // Increment ply
 28,133,097    0    0   9,377,699         0    0   9,377,699       0     0           0          0  0   0    p->ply++;
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    tbassert(p->key == compute_zob_key(p),
          .    .    .           .         .    .           .       .     .           .          .  .   .             "p->key: %"PRIu64", zob-key: %"PRIu64"\n",
          .    .    .           .         .    .           .       .     .           .          .  .   .             p->key, compute_zob_key(p));
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    WHEN_DEBUG_VERBOSE({
          .    .    .           .         .    .           .       .     .           .          .  .   .        fprintf(stderr, "After:\n");
          .    .    .           .         .    .           .       .     .           .          .  .   .        display(p);
-- line 340 ----------------------------------------
-- line 342 ----------------------------------------
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    return stomped_dst_sq;
          .    .    .           .         .    .           .       .     .           .          .  .   .  }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  // returns square of piece to be removed from board or 0
          .    .    .           .         .    .           .       .     .           .          .  .   .  square_t fire(position_t *p) {
          .    .    .           .         .    .           .       .     .           .          .  .   .    color_t fake_color_to_move = (color_to_move_of(p) == WHITE) ? BLACK : WHITE;
 28,133,097    0    0   9,377,699         0    0           0       0     0           0          0  0   0    square_t sq = p->kloc[fake_color_to_move];
  9,377,699    0    0           0         0    0           0       0     0           0          0  0   0    int bdir = ori_of(p->board[sq]);
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    tbassert(ptype_of(p->board[ p->kloc[fake_color_to_move] ]) == KING,
          .    .    .           .         .    .           .       .     .           .          .  .   .             "ptype_of(p->board[ p->kloc[fake_color_to_move] ]): %d\n",
          .    .    .           .         .    .           .       .     .           .          .  .   .             ptype_of(p->board[ p->kloc[fake_color_to_move] ]));
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    while (true) {
143,352,346    0    0           0         0    0           0       0     0           0          0  0   0      sq += beam_of(bdir);
          .    .    .           .         .    .           .       .     .           .          .  .   .      tbassert(sq < ARR_SIZE && sq >= 0, "sq: %d\n", sq);
          .    .    .           .         .    .           .       .     .           .          .  .   .  
555,603,230    1    1  71,676,173         0    0           0       0     0 206,125,442 13,916,624  0   0      switch (ptype_of(p->board[sq])) {
          .    .    .           .         .    .           .       .     .           .          .  .   .        case EMPTY:  // empty square
          .    .    .           .         .    .           .       .     .           .          .  .   .          break;
          .    .    .           .         .    .           .       .     .           .          .  .   .        case PAWN:  // Pawn
          .    .    .           .         .    .           .       .     .           .          .  .   .          bdir = reflect_of(bdir, ori_of(p->board[sq]));
 14,899,544    0    0           0         0    0           0       0     0   7,183,311    531,260  0   0          if (bdir < 0) {  // Hit back of Pawn
          .    .    .           .         .    .           .       .     .           .          .  .   .            return sq;
          .    .    .           .         .    .           .       .     .           .          .  .   .          }
          .    .    .           .         .    .           .       .     .           .          .  .   .          break;
          .    .    .           .         .    .           .       .     .           .          .  .   .        case KING:  // King
          .    .    .           .         .    .           .       .     .           .          .  .   .          return sq;  // sorry, game over my friend!
          .    .    .           .         .    .           .       .     .           .          .  .   .          break;
          .    .    .           .         .    .           .       .     .           .          .  .   .        case INVALID:  // Ran off edge of board
          .    .    .           .         .    .           .       .     .           .          .  .   .          return 0;
-- line 374 ----------------------------------------
-- line 377 ----------------------------------------
          .    .    .           .         .    .           .       .     .           .          .  .   .          tbassert(false, "Like porkchops and whipped cream.\n");
          .    .    .           .         .    .           .       .     .           .          .  .   .          break;
          .    .    .           .         .    .           .       .     .           .          .  .   .      }
          .    .    .           .         .    .           .       .     .           .          .  .   .    }
          .    .    .           .         .    .           .       .     .           .          .  .   .  }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  // return victim pieces or KO
103,154,689    1    1           0         0    0  65,643,893   7,133     0           0          0  0   0  victims_t make_move(position_t *old, position_t *p, move_t mv) {
          .    .    .           .         .    .           .       .     .           .          .  .   .    tbassert(mv != 0, "mv was zero.\n");
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    WHEN_DEBUG_VERBOSE(char buf[MAX_CHARS_IN_MOVE]);
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    // move phase 1 - moving a piece, which may result in a stomp
          .    .    .           .         .    .           .       .     .           .          .  .   .    square_t stomped_sq = low_level_make_move(old, p, mv);
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    WHEN_DEBUG_VERBOSE({
          .    .    .           .         .    .           .       .     .           .          .  .   .        if (stomped_sq != 0) {
          .    .    .           .         .    .           .       .     .           .          .  .   .          square_to_str(stomped_sq, buf, MAX_CHARS_IN_MOVE);
          .    .    .           .         .    .           .       .     .           .          .  .   .          DEBUG_LOG(1, "Stomping piece on %s\n", buf);
          .    .    .           .         .    .           .       .     .           .          .  .   .        }
          .    .    .           .         .    .           .       .     .           .          .  .   .      });
          .    .    .           .         .    .           .       .     .           .          .  .   .  
 12,178,346    1    1   6,089,173         0    0           0       0     0   6,089,173     25,384  0   0    if (stomped_sq == 0) {
 18,737,018    1    1           0         0    0   9,359,319       0     0           0          0  0   0      p->victims.stomped = 0;
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .      // Don't check for Ko yet.
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    } else {  // we definitely stomped something
     55,140    0    0      36,760         0    0      18,380       0     0           0          0  0   0      p->victims.stomped = p->board[stomped_sq];
     36,760    0    0           0         0    0           0       0     0      18,380      3,249  0   0      if (color_of(p->victims.stomped) == WHITE) {
      5,873    0    0       5,873         0    0           0       0     0           0          0  0   0        p->white_pawn_count -= 1;
          .    .    .           .         .    .           .       .     .           .          .  .   .      }
          .    .    .           .         .    .           .       .     .           .          .  .   .      else if (color_of(p->victims.stomped) == BLACK) {
     25,014    0    0      12,507         0    0           0       0     0           0          0  0   0        p->black_pawn_count -= 1;
          .    .    .           .         .    .           .       .     .           .          .  .   .      }
     91,900    0    0      18,380         0    0      18,380       0     0           0          0  0   0      p->key ^= zob[stomped_sq][p->victims.stomped];   // remove from board
     18,380    0    0           0         0    0      18,380       0     0           0          0  0   0      p->board[stomped_sq] = 0;
     73,520    0    0      18,380     3,530    0      18,380       0     0           0          0  0   0      p->key ^= zob[stomped_sq][p->board[stomped_sq]];
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .      tbassert(p->key == compute_zob_key(p),
          .    .    .           .         .    .           .       .     .           .          .  .   .               "p->key: %"PRIu64", zob-key: %"PRIu64"\n",
          .    .    .           .         .    .           .       .     .           .          .  .   .               p->key, compute_zob_key(p));
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .      WHEN_DEBUG_VERBOSE({
          .    .    .           .         .    .           .       .     .           .          .  .   .          square_to_str(stomped_sq, buf, MAX_CHARS_IN_MOVE);
          .    .    .           .         .    .           .       .     .           .          .  .   .          DEBUG_LOG(1, "Stomped piece on %s\n", buf);
-- line 423 ----------------------------------------
-- line 429 ----------------------------------------
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .    WHEN_DEBUG_VERBOSE({
          .    .    .           .         .    .           .       .     .           .          .  .   .        if (victim_sq != 0) {
          .    .    .           .         .    .           .       .     .           .          .  .   .          square_to_str(victim_sq, buf, MAX_CHARS_IN_MOVE);
          .    .    .           .         .    .           .       .     .           .          .  .   .          DEBUG_LOG(1, "Zapping piece on %s\n", buf);
          .    .    .           .         .    .           .       .     .           .          .  .   .        }
          .    .    .           .         .    .           .       .     .           .          .  .   .      });
          .    .    .           .         .    .           .       .     .           .          .  .   .  
  1,182,444    0    0           0         0    0           0       0     0     591,222        165  0   0    if (victim_sq == 0) {
  8,786,477    0    0           0         0    0   8,786,477       0     0           0          0  0   0      p->victims.zapped = 0;
          .    .    .           .         .    .           .       .     .           .          .  .   .  
 26,359,431   10    1   8,786,477         1    0           0       0     0   8,786,477          2  0   0      if (USE_KO &&  // Ko rule
 17,688,833    0    0   8,768,305         0    0           0       0     0   8,768,305    152,268  0   0          zero_victims(p->victims) &&
 26,304,915    6    1   8,768,305         0    0           0       0     0           0          0  0   0          (p->key == (old->key ^ zob_color))) {
          .    .    .           .         .    .           .       .     .           .          .  .   .        return KO();
          .    .    .           .         .    .           .       .     .           .          .  .   .      }
          .    .    .           .         .    .           .       .     .           .          .  .   .    } else {  // we definitely hit something with laser
    591,222    0    0           0         0    0     591,222       0     0           0          0  0   0      p->victims.zapped = p->board[victim_sq];
  1,182,444    2    1           0         0    0           0       0     0     591,222     95,029  0   0      if (color_of(p->victims.zapped) == WHITE) {
    356,327    0    0     356,327         0    0           0       0     0           0          0  0   0        p->white_pawn_count -= 1;
          .    .    .           .         .    .           .       .     .           .          .  .   .      }
          .    .    .           .         .    .           .       .     .           .          .  .   .      else if (color_of(p->victims.zapped) == BLACK) {
    469,790    1    1     234,895         0    0           0       0     0           0          0  0   0        p->black_pawn_count -= 1;
          .    .    .           .         .    .           .       .     .           .          .  .   .      }
  3,547,332    0    0   1,182,444    35,632    0     591,222       0     0           0          0  0   0      p->key ^= zob[victim_sq][p->victims.zapped];   // remove from board
    591,222    0    0           0         0    0     591,222       0     0           0          0  0   0      p->board[victim_sq] = 0;
  1,773,666    0    0     591,222    60,856    0     591,222       0     0           0          0  0   0      p->key ^= zob[victim_sq][0];
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .      tbassert(p->key == compute_zob_key(p),
          .    .    .           .         .    .           .       .     .           .          .  .   .               "p->key: %"PRIu64", zob-key: %"PRIu64"\n",
          .    .    .           .         .    .           .       .     .           .          .  .   .               p->key, compute_zob_key(p));
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .      WHEN_DEBUG_VERBOSE({
          .    .    .           .         .    .           .       .     .           .          .  .   .          square_to_str(victim_sq, buf, MAX_CHARS_IN_MOVE);
          .    .    .           .         .    .           .       .     .           .          .  .   .          DEBUG_LOG(1, "Zapped piece on %s\n", buf);
          .    .    .           .         .    .           .       .     .           .          .  .   .        });
          .    .    .           .         .    .           .       .     .           .          .  .   .    }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
  9,225,476    0    0   9,225,476         0    0           0       0     0           0          0  0   0    return p->victims;
 75,021,592    0    0  65,643,893         0    0           0       0     0           0          0  0   0  }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  // helper function for do_perft
          .    .    .           .         .    .           .       .     .           .          .  .   .  // ply starting with 0
          .    .    .           .         .    .           .       .     .           .          .  .   .  static uint64_t perft_search(position_t *p, int depth, int ply) {
          .    .    .           .         .    .           .       .     .           .          .  .   .    uint64_t node_count = 0;
          .    .    .           .         .    .           .       .     .           .          .  .   .    position_t np;
          .    .    .           .         .    .           .       .     .           .          .  .   .    sortable_move_t lst[MAX_NUM_MOVES];
          .    .    .           .         .    .           .       .     .           .          .  .   .    int num_moves;
-- line 476 ----------------------------------------
-- line 601 ----------------------------------------
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  bool is_ILLEGAL(victims_t victims) {
          .    .    .           .         .    .           .       .     .           .          .  .   .    return (victims.stomped == ILLEGAL_STOMPED) ||
          .    .    .           .         .    .           .       .     .           .          .  .   .        (victims.zapped == ILLEGAL_ZAPPED);
          .    .    .           .         .    .           .       .     .           .          .  .   .  }
          .    .    .           .         .    .           .       .     .           .          .  .   .  
          .    .    .           .         .    .           .       .     .           .          .  .   .  
  3,980,244    1    1           0         0    0   1,990,122       0     0           0          0  0   0  bool victim_exists(victims_t victims) {
  3,943,564    0    0           0         0    0           0       0     0     995,061    686,163  0   0    return (victims.stomped > 0) ||
  1,953,442    0    0           0         0    0           0       0     0           0          0  0   0        (victims.zapped > 0);
  1,990,122    0    0   1,990,122         0    0           0       0     0           0          0  0   0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./././move_gen.h
--------------------------------------------------------------------------------
         Ir I1mr ILmr         Dr   D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim 

-- line 157 ----------------------------------------
          .    .    .          .      .    .  .    .    .  .   .  .   .    if ((p->ply & 1) == 0) {
          .    .    .          .      .    .  .    .    .  .   .  .   .      return WHITE;
          .    .    .          .      .    .  .    .    .  .   .  .   .    } else {
          .    .    .          .      .    .  .    .    .  .   .  .   .      return BLACK;
          .    .    .          .      .    .  .    .    .  .   .  .   .    }
          .    .    .          .      .    .  .    .    .  .   .  .   .  }
          .    .    .          .      .    .  .    .    .  .   .  .   .  
          .    .    .          .      .    .  .    .    .  .   .  .   .  inline color_t color_of(piece_t x) {
275,224,570    0    0          0      0    0  0    0    0  0   0  0   0    return (color_t) ((x >> COLOR_SHIFT) & COLOR_MASK);
          .    .    .          .      .    .  .    .    .  .   .  .   .  }
          .    .    .          .      .    .  .    .    .  .   .  .   .  
          .    .    .          .      .    .  .    .    .  .   .  .   .  inline color_t opp_color(color_t c) {
  1,730,546    0    0          0      0    0  0    0    0  0   0  0   0    if (c == WHITE) {
          .    .    .          .      .    .  .    .    .  .   .  .   .      return BLACK;
          .    .    .          .      .    .  .    .    .  .   .  .   .    } else {
          .    .    .          .      .    .  .    .    .  .   .  .   .      return WHITE;
          .    .    .          .      .    .  .    .    .  .   .  .   .    }
          .    .    .          .      .    .  .    .    .  .   .  .   .  }
          .    .    .          .      .    .  .    .    .  .   .  .   .  
          .    .    .          .      .    .  .    .    .  .   .  .   .  
          .    .    .          .      .    .  .    .    .  .   .  .   .  inline void set_color(piece_t *x, color_t c) {
          .    .    .          .      .    .  .    .    .  .   .  .   .    tbassert((c >= 0) & (c <= COLOR_MASK), "color: %d\n", c);
          .    .    .          .      .    .  .    .    .  .   .  .   .    *x = ((c & COLOR_MASK) << COLOR_SHIFT) |
          .    .    .          .      .    .  .    .    .  .   .  .   .        (*x & ~(COLOR_MASK << COLOR_SHIFT));
          .    .    .          .      .    .  .    .    .  .   .  .   .  }
          .    .    .          .      .    .  .    .    .  .   .  .   .  
          .    .    .          .      .    .  .    .    .  .   .  .   .  
          .    .    .          .      .    .  .    .    .  .   .  .   .  inline ptype_t ptype_of(piece_t x) {
262,974,068   13    4          0      0    0  0    0    0  0   0  0   0    return (ptype_t) ((x >> PTYPE_SHIFT) & PTYPE_MASK);
          .    .    .          .      .    .  .    .    .  .   .  .   .  }
          .    .    .          .      .    .  .    .    .  .   .  .   .  
          .    .    .          .      .    .  .    .    .  .   .  .   .  inline void set_ptype(piece_t *x, ptype_t pt) {
          .    .    .          .      .    .  .    .    .  .   .  .   .    *x = ((pt & PTYPE_MASK) << PTYPE_SHIFT) |
          .    .    .          .      .    .  .    .    .  .   .  .   .        (*x & ~(PTYPE_MASK << PTYPE_SHIFT));
          .    .    .          .      .    .  .    .    .  .   .  .   .  }
          .    .    .          .      .    .  .    .    .  .   .  .   .  
          .    .    .          .      .    .  .    .    .  .   .  .   .  inline int ori_of(piece_t x) {
  3,825,669    1    1  2,095,123      1    0  0    0    0  0   0  0   0    return (x >> ORI_SHIFT) & ORI_MASK;
          .    .    .          .      .    .  .    .    .  .   .  .   .  }
          .    .    .          .      .    .  .    .    .  .   .  .   .  
          .    .    .          .      .    .  .    .    .  .   .  .   .  inline void set_ori(piece_t *x, int ori) {
          .    .    .          .      .    .  .    .    .  .   .  .   .    *x = ((ori & ORI_MASK) << ORI_SHIFT) |
          .    .    .          .      .    .  .    .    .  .   .  .   .        (*x & ~(ORI_MASK << ORI_SHIFT));
          .    .    .          .      .    .  .    .    .  .   .  .   .  }
          .    .    .          .      .    .  .    .    .  .   .  .   .  void init_zob();
          .    .    .          .      .    .  .    .    .  .   .  .   .  // For no square, use 0, which is guaranteed to be off board
-- line 202 ----------------------------------------
-- line 229 ----------------------------------------
          .    .    .          .      .    .  .    .    .  .   .  .   .  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
          .    .    .          .      .    .  .    .    .  .   .  .   .  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
          .    .    .          .      .    .  .    .    .  .   .  .   .  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
          .    .    .          .      .    .  .    .    .  .   .  .   .  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
          .    .    .          .      .    .  .    .    .  .   .  .   .  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
          .    .    .          .      .    .  .    .    .  .   .  .   .  };
          .    .    .          .      .    .  .    .    .  .   .  .   .  
          .    .    .          .      .    .  .    .    .  .   .  .   .  inline static fil_t fil_of(square_t sq) {
 23,119,826    1    1 23,119,826      0    0  0    0    0  0   0  0   0    fil_t f = fil_of_table[sq];
          .    .    .          .      .    .  .    .    .  .   .  .   .    DEBUG_LOG(1, "File of square %d is %d\n", sq, f);
          .    .    .          .      .    .  .    .    .  .   .  .   .    return f;
          .    .    .          .      .    .  .    .    .  .   .  .   .  }
          .    .    .          .      .    .  .    .    .  .   .  .   .  // Finds rank of square
          .    .    .          .      .    .  .    .    .  .   .  .   .  inline rnk_t rnk_of_old(square_t sq) {
          .    .    .          .      .    .  .    .    .  .   .  .   .    rnk_t r = ((sq >> RNK_SHIFT) & RNK_MASK) - RNK_ORIGIN;
          .    .    .          .      .    .  .    .    .  .   .  .   .    DEBUG_LOG(1, "Rank of square %d is %d\n", sq, r);
          .    .    .          .      .    .  .    .    .  .   .  .   .    return r;
-- line 245 ----------------------------------------
-- line 260 ----------------------------------------
          .    .    .          .      .    .  .    .    .  .   .  .   .  -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
          .    .    .          .      .    .  .    .    .  .   .  .   .  -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
          .    .    .          .      .    .  .    .    .  .   .  .   .  -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
          .    .    .          .      .    .  .    .    .  .   .  .   .  -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
          .    .    .          .      .    .  .    .    .  .   .  .   .  -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12
          .    .    .          .      .    .  .    .    .  .   .  .   .  };
          .    .    .          .      .    .  .    .    .  .   .  .   .  
          .    .    .          .      .    .  .    .    .  .   .  .   .  inline static rnk_t rnk_of(square_t sq) {
 37,584,098    0    0          0      0    0  0    0    0  0   0  0   0    rnk_t r = rnk_of_table[sq];
          .    .    .          .      .    .  .    .    .  .   .  .   .    DEBUG_LOG(1, "Rank of square %d is %d\n", sq, r);
          .    .    .          .      .    .  .    .    .  .   .  .   .    return r;
          .    .    .          .      .    .  .    .    .  .   .  .   .  }
          .    .    .          .      .    .  .    .    .  .   .  .   .  int square_to_str(square_t sq, char *buf, size_t bufsize);
          .    .    .          .      .    .  .    .    .  .   .  .   .  // direction map
          .    .    .          .      .    .  .    .    .  .   .  .   .  static int dir[8] = { -ARR_WIDTH - 1, -ARR_WIDTH, -ARR_WIDTH + 1, -1, 1,
          .    .    .          .      .    .  .    .    .  .   .  .   .                        ARR_WIDTH - 1, ARR_WIDTH, ARR_WIDTH + 1 };
          .    .    .          .      .    .  .    .    .  .   .  .   .  inline static int dir_of(int i) {
-- line 276 ----------------------------------------
-- line 295 ----------------------------------------
          .    .    .          .      .    .  .    .    .  .   .  .   .    { NN, -1, -1, SS},   // EE
          .    .    .          .      .    .  .    .    .  .   .  .   .    { WW, EE, -1, -1 },  // SS
          .    .    .          .      .    .  .    .    .  .   .  .   .    { -1, NN, SS, -1 }   // WW
          .    .    .          .      .    .  .    .    .  .   .  .   .  };
          .    .    .          .      .    .  .    .    .  .   .  .   .  
          .    .    .          .      .    .  .    .    .  .   .  .   .  inline static int reflect_of(int beam_dir, int pawn_ori) {
          .    .    .          .      .    .  .    .    .  .   .  .   .    tbassert(beam_dir >= 0 && beam_dir < NUM_ORI, "beam-dir: %d\n", beam_dir);
          .    .    .          .      .    .  .    .    .  .   .  .   .    tbassert(pawn_ori >= 0 && pawn_ori < NUM_ORI, "pawn-ori: %d\n", pawn_ori);
  5,903,178    0    0  1,967,726 80,108    1  0    0    0  0   0  0   0    return reflect[beam_dir][pawn_ori];
          .    .    .          .      .    .  .    .    .  .   .  .   .  }
          .    .    .          .      .    .  .    .    .  .   .  .   .  // -----------------------------------------------------------------------------
          .    .    .          .      .    .  .    .    .  .   .  .   .  // Move getters and setters.
          .    .    .          .      .    .  .    .    .  .   .  .   .  // -----------------------------------------------------------------------------
          .    .    .          .      .    .  .    .    .  .   .  .   .  
          .    .    .          .      .    .  .    .    .  .   .  .   .  inline ptype_t ptype_mv_of(move_t mv) {
          .    .    .          .      .    .  .    .    .  .   .  .   .    return (ptype_t) ((mv >> PTYPE_MV_SHIFT) & PTYPE_MV_MASK);
          .    .    .          .      .    .  .    .    .  .   .  .   .  }
-- line 311 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./search_common.c
--------------------------------------------------------------------------------
           Ir I1mr ILmr          Dr    D1mr DLmr          Dw    D1mw DLmw          Bc        Bcm Bi Bim 

-- line 41 ----------------------------------------
            .    .    .           .       .    .           .       .    .           .          .  .   .  static sort_key_t sort_key(sortable_move_t mv) {
            .    .    .           .       .    .           .       .    .           .          .  .   .    return (sort_key_t) ((mv >> SORT_SHIFT) & SORT_MASK);
            .    .    .           .       .    .           .       .    .           .          .  .   .  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  */
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  static void set_sort_key(sortable_move_t *mv, sort_key_t key) {
            .    .    .           .       .    .           .       .    .           .          .  .   .    // sort keys must not exceed SORT_MASK
            .    .    .           .       .    .           .       .    .           .          .  .   .    //  assert ((0 <= key) && (key <= SORT_MASK));
  111,886,863    0    0  21,770,602 390,542    0  22,296,551       0    0           0          0  0   0    *mv = ((((uint64_t) key) & SORT_MASK) << SORT_SHIFT) |
   22,313,168    0    0           0       0    0           0       0    0           0          0  0   0          (*mv & ~(SORT_MASK << SORT_SHIFT));
            .    .    .           .       .    .           .       .    .           .          .  .   .    return;
            .    .    .           .       .    .           .       .    .           .          .  .   .  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            5    1    1           0       0    0           3       0    0           0          0  0   0  void init_abort_timer(double goal_time) {
            3    1    1           0       0    0           2       1    1           0          0  0   0    sstart = milliseconds();
            .    .    .           .       .    .           .       .    .           .          .  .   .    // don't go over any more than 3 times the goal
            4    0    0           2       1    1           1       0    0           0          0  0   0    timeout = sstart + goal_time * 3.0;
            2    0    0           2       0    0           0       0    0           0          0  0   0  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
           21    0    0           0       0    0          14       0    0           0          0  0   0  double elapsed_time() {
           91    1    1          17       0    0          37       0    0           0          0  0   0    return milliseconds() - sstart;
           14    0    0          14       0    0           0       0    0           0          0  0   0  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
           21    0    0           0       0    0          14       0    0           0          0  0   0  bool should_abort() {
            .    .    .           .       .    .           .       .    .           .          .  .   .    return abortf;
           21    0    0          21       0    0           0       0    0           0          0  0   0  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
           21    1    1           0       0    0          14       0    0           0          0  0   0  void reset_abort() {
            7    0    0           0       0    0           7       0    0           0          0  0   0    abortf = false;
           14    0    0          14       0    0           0       0    0           0          0  0   0  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            3    1    1           0       0    0           2       0    0           0          0  0   0  void init_tics() {
            1    0    0           0       0    0           1       1    0           0          0  0   0    tics = 0;
            2    0    0           2       0    0           0       0    0           0          0  0   0  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  move_t get_move(sortable_move_t sortable_mv) {
   95,109,179    2    2  20,554,772  74,208    0  19,669,257     374    0           0          0  0   0    return (move_t) (sortable_mv & MOVE_MASK);
            .    .    .           .       .    .           .       .    .           .          .  .   .  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  static score_t get_draw_score(position_t *p, int ply) {
            .    .    .           .       .    .           .       .    .           .          .  .   .    position_t *x = p->history;
            .    .    .           .       .    .           .       .    .           .          .  .   .    uint64_t cur = p->key;
            .    .    .           .       .    .           .       .    .           .          .  .   .    score_t score;
            .    .    .           .       .    .           .       .    .           .          .  .   .    while (true) {
            .    .    .           .       .    .           .       .    .           .          .  .   .      if (!zero_victims(x->victims)) {
            .    .    .           .       .    .           .       .    .           .          .  .   .        break;  // cannot be a repetition
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
            8    0    0           8       0    0           0       0    0           0          0  0   0      x = x->history;
            .    .    .           .       .    .           .       .    .           .          .  .   .      if (!zero_victims(x->victims)) {
            .    .    .           .       .    .           .       .    .           .          .  .   .        break;  // cannot be a repetition
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
           40    0    0           8       0    0           0       0    0          16          1  0   0      if (x->key == cur) {  // is a repetition
           16    0    0           0       0    0           0       0    0           8          2  0   0        if (ply & 1) {
            .    .    .           .       .    .           .       .    .           .          .  .   .          score = -DRAW;
            .    .    .           .       .    .           .       .    .           .          .  .   .        } else {
            8    0    0           8       0    0           0       0    0           0          0  0   0          score = DRAW;
            .    .    .           .       .    .           .       .    .           .          .  .   .        }
            .    .    .           .       .    .           .       .    .           .          .  .   .        return score;
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
            8    0    0           8       0    0           0       0    0           0          0  0   0      x = x->history;
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .    assert(false);  // This should not occur.
            8    0    0           0       0    0           0       0    0           0          0  0   0    return (score_t) 0;
            .    .    .           .       .    .           .       .    .           .          .  .   .  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  // Detect move repetition
            .    .    .           .       .    .           .       .    .           .          .  .   .  static bool is_repeated(position_t *p, int ply) {
    4,030,317    1    1   1,343,439       0    0           0       0    0   1,343,439         14  0   0    if (!DETECT_DRAWS) {
            .    .    .           .       .    .           .       .    .           .          .  .   .      return false;  // no draw detected
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
    1,343,439    2    2   1,343,439       0    0           0       0    0           0          0  0   0    position_t *x = p->history;
    1,343,439    0    0   1,343,439       0    0           0       0    0           0          0  0   0    uint64_t cur = p->key;
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    while (true) {
            .    .    .           .       .    .           .       .    .           .          .  .   .      if (!zero_victims(x->victims)) {
            .    .    .           .       .    .           .       .    .           .          .  .   .        break;  // cannot be a repetition
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
    2,124,700    0    0   2,124,700       0    0           0       0    0           0          0  0   0      x = x->history;
            .    .    .           .       .    .           .       .    .           .          .  .   .      if (!zero_victims(x->victims)) {
            .    .    .           .       .    .           .       .    .           .          .  .   .        break;  // cannot be a repetition
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
    4,626,580    0    0   1,555,476       0    0           0       0    0   1,555,476         14  0   0      if (x->key == cur) {  // is a repetition
            .    .    .           .       .    .           .       .    .           .          .  .   .        return true;
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
    1,555,468    0    0   1,555,468       0    0           0       0    0           0          0  0   0      x = x->history;
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .    return false;
            .    .    .           .       .    .           .       .    .           .          .  .   .  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  // check the victim pieces returned by the move to determine if it's a
            .    .    .           .       .    .           .       .    .           .          .  .   .  // game-over situation.  If so, also calculate the score depending on
            .    .    .           .       .    .           .       .    .           .          .  .   .  // the pov (which player's point of view)
            .    .    .           .       .    .           .       .    .           .          .  .   .  static bool is_game_over(victims_t victims, int pov, int ply) {
            .    .    .           .       .    .           .       .    .           .          .  .   .    tbassert(ptype_of(victims.stomped) != KING, "Stomped a king.\n");
   18,450,952    0    0           0       0    0           0       0    0   9,225,476          6  0   0    if (ptype_of(victims.zapped) == KING) {
            .    .    .           .       .    .           .       .    .           .          .  .   .      return true;
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .    return false;
            .    .    .           .       .    .           .       .    .           .          .  .   .  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  static score_t get_game_over_score(victims_t victims, int pov, int ply) {
            .    .    .           .       .    .           .       .    .           .          .  .   .    tbassert(ptype_of(victims.stomped) != KING, "Stomped a king.\n");
            .    .    .           .       .    .           .       .    .           .          .  .   .    score_t score;
      116,600    0    0           0       0    0           0       0    0      58,300          3  0   0    if (color_of(victims.zapped) == WHITE) {
      161,185    0    0           0       0    0           0       0    0           0          0  0   0      score = -WIN * pov;
            .    .    .           .       .    .           .       .    .           .          .  .   .    } else {
       52,126    0    0           0       0    0           0       0    0           0          0  0   0      score = WIN * pov;
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .    if (score < 0) {
      349,800    0    0           0       0    0           0       0    0           0          0  0   0      score += ply;
            .    .    .           .       .    .           .       .    .           .          .  .   .    } else {
            .    .    .           .       .    .           .       .    .           .          .  .   .      score -= ply;
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .    return score;
            .    .    .           .       .    .           .       .    .           .          .  .   .  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  static void getPV(move_t *pv, char *buf, size_t bufsize) {
           50    0    0          10       0    0          10       0    0           0          0  0   0    buf[0] = 0;
            .    .    .           .       .    .           .       .    .           .          .  .   .  
          286   10    1          58       0    0           0       0    0          76         14  0   0    for (int i = 0; i < (MAX_PLY_IN_SEARCH - 1) && pv[i] != 0; i++) {
            .    .    .           .       .    .           .       .    .           .          .  .   .      char a[MAX_CHARS_IN_MOVE];
          114    0    0           0       0    0          38       0    0           0          0  0   0      move_to_str(pv[i], a, MAX_CHARS_IN_MOVE);
           76    0    0           0       0    0           0       0    0          38         13  0   0      if (i != 0) {
        1,116    1    1          98       0    0          28       0    0          98         36  0   0        strncat(buf, " ", bufsize - strlen(buf) - 1);  // - 1, for the terminating '\0'
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
        1,452    2    2         126       0    0          38       0    0         126         34  0   0      strncat(buf, a, bufsize - strlen(buf) - 1);  // - 1, for the terminating '\0'
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  static void print_move_info(move_t mv, int ply) {
            .    .    .           .       .    .           .       .    .           .          .  .   .    char buf[MAX_CHARS_IN_MOVE];
            7    0    0           0       0    0           0       0    0           0          0  0   0    move_to_str(mv, buf, MAX_CHARS_IN_MOVE);
            .    .    .           .       .    .           .       .    .           .          .  .   .    printf("info");
            .    .    .           .       .    .           .       .    .           .          .  .   .    for (int i = 0; i < ply; ++i) {
            .    .    .           .       .    .           .       .    .           .          .  .   .      printf(" ----");
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .    printf(" %s\n", buf);
            .    .    .           .       .    .           .       .    .           .          .  .   .  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  // Evaluates the node before performing a full search.
            .    .    .           .       .    .           .       .    .           .          .  .   .  //   does a few things differently if in scout search.
    8,958,897    1    1           0       0    0   4,977,165       0    0           0          0  0   0  leafEvalResult evaluate_as_leaf(searchNode *node, searchType_t type) {
            .    .    .           .       .    .           .       .    .           .          .  .   .    leafEvalResult result;
            .    .    .           .       .    .           .       .    .           .          .  .   .    result.type = MOVE_IGNORE;
      208,958    0    0           0       0    0           0       0    0           0          0  0   0    result.score = -INF;
            .    .    .           .       .    .           .       .    .           .          .  .   .    result.should_enter_quiescence = false;
    1,671,736    2    2           0       0    0           0       0    0           0          0  0   0    result.hash_table_move = 0;
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    // get transposition table record if available.
    2,987,235    0    0     995,901       0    0     995,901       0    0           0          0  0   0    ttRec_t *rec = tt_hashtable_get(node->position.key);
    1,991,802    0    0           0       0    0           0       0    0     995,901    502,995  0   0    if (rec) {
    1,278,008    0    0     319,502       0    0     159,751       0    0     319,502        133  0   0      if (type == SEARCH_SCOUT && tt_is_usable(rec, node->depth, node->beta)) {
            .    .    .           .       .    .           .       .    .           .          .  .   .        result.type = MOVE_EVALUATED;
      391,884    0    0     130,628       0    0     130,628       0    0           0          0  0   0        result.score = tt_adjust_score_from_hashtable(rec, node->ply);
      391,884    0    0           0       0    0           0       0    0           0          0  0   0        return result;
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
       88,215    0    0           0       0    0      29,405       0    0           0          0  0   0      result.hash_table_move = tt_move_of(rec);
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    // stand pat (having-the-move) bonus
    5,360,710    1    1     865,273       0    0     865,273       0    0           0          0  0   0    score_t sps = eval(&(node->position), false) + HMB;
    2,594,415    0    0     864,805       0    0           0       0    0           0          0  0   0    bool quiescence = (node->depth <= 0);  // are we in quiescence?
      864,805    0    0           0       0    0           0       0    0           0          0  0   0    result.should_enter_quiescence = quiescence;
    1,731,014    1    1         468       0    0           0       0    0     865,273    133,511  0   0    if (quiescence) {
            .    .    .           .       .    .           .       .    .           .          .  .   .      result.score = sps;
    1,969,320    1    1     656,440       0    0           0       0    0     656,440     38,868  0   0      if (result.score >= node->beta) {
            .    .    .           .       .    .           .       .    .           .          .  .   .        result.type = MOVE_EVALUATED;
    2,501,475    0    0           0       0    0           0       0    0           0          0  0   0        return result;
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    // margin based forward pruning
    1,822,550    1    1     364,510       0    0           0       0    0     729,020         18  0   0    if (type == SEARCH_SCOUT && USE_NMM) {
      729,020    0    0           0       0    0           0       0    0     364,510      7,873  0   0      if (node->depth <= 2) {
    1,793,570    0    0     179,647       0    0           0       0    0     537,491     20,688  0   0        if (node->depth == 1 && sps >= node->beta + 3 * PAWN_VALUE) {
            .    .    .           .       .    .           .       .    .           .          .  .   .          result.type = MOVE_EVALUATED;
            .    .    .           .       .    .           .       .    .           .          .  .   .          result.score = node->beta;
            .    .    .           .       .    .           .       .    .           .          .  .   .          return result;
            .    .    .           .       .    .           .       .    .           .          .  .   .        }
      490,764    0    0      22,395       0    0           0       0    0     200,592          3  0   0        if (node->depth == 2 && sps >= node->beta + 5 * PAWN_VALUE) {
            .    .    .           .       .    .           .       .    .           .          .  .   .          result.type = MOVE_EVALUATED;
            .    .    .           .       .    .           .       .    .           .          .  .   .          result.score = node->beta;
        1,626    0    0           0       0    0           0       0    0           0          0  0   0          return result;
            .    .    .           .       .    .           .       .    .           .          .  .   .        }
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    // futility pruning
    1,055,451    1    1     364,239       0    0           0       0    0     525,164      6,745  0   0    if (type == SEARCH_SCOUT && node->depth <= FUT_DEPTH && node->depth > 0) {
      620,682    0    0     413,788     355    0           0       0    0           0          0  0   0      if (sps + fmarg[node->depth] < node->beta) {
            .    .    .           .       .    .           .       .    .           .          .  .   .        // treat this ply as a quiescence ply, look only at captures
            .    .    .           .       .    .           .       .    .           .          .  .   .        result.should_enter_quiescence = true;
            .    .    .           .       .    .           .       .    .           .          .  .   .        result.score = sps;
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
    2,185,434    0    0           0       0    0           0       0    0           0          0  0   0    return result;
    6,968,031    1    1   4,977,165       0    0           0       0    0           0          0  0   0  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  // Evaluate the move by performing a search.
            .    .    .           .       .    .           .       .    .           .          .  .   .  moveEvaluationResult* evaluateMove(searchNode *node, move_t mv, move_t killer_a,
            .    .    .           .       .    .           .       .    .           .          .  .   .                                    move_t killer_b, searchType_t type,
  150,035,344    1    1   9,377,209       0    0  84,394,881       0    0           0          0  0   0                                    uint64_t *node_count_serial, moveEvaluationResult *result) {
    3,980,244    0    0     995,061       0    0           0       0    0           0          0  0   0    int ext = 0;  // extensions
            .    .    .           .       .    .           .       .    .           .          .  .   .    bool blunder = false;  // shoot our own piece
    9,377,209    1    1           0       0    0   9,377,209   6,470   18           0          0  0   0    result->next_node.subpv[0] = 0;
    9,377,209    0    0           0       0    0   9,377,209       0    0           0          0  0   0    result->next_node.parent = node;
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    // Make the move, and get any victim pieces.
   56,263,254    0    0           0       0    0   9,377,209       0    0           0          0  0   0    victims_t victims = make_move(&(node->position), &(result->next_node.position),
            .    .    .           .       .    .           .       .    .           .          .  .   .                                  mv);
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    // Check whether this move changes the board state.
            .    .    .           .       .    .           .       .    .           .          .  .   .    //   such moves are not legal.
            .    .    .           .       .    .           .       .    .           .          .  .   .    if (is_KO(victims)) {
      152,216    0    0           0       0    0     152,216       0    0           0          0  0   0      result->type = MOVE_ILLEGAL;
            .    .    .           .       .    .           .       .    .           .          .  .   .      return result;
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    // Check whether the game is over.
            .    .    .           .       .    .           .       .    .           .          .  .   .    if (is_game_over(victims, node->pov, node->ply)) {
            .    .    .           .       .    .           .       .    .           .          .  .   .      // Compute the end-game score.
       58,300    0    0           0       0    0      58,300       0    0           0          0  0   0      result->type = MOVE_GAMEOVER;
      174,900    0    0     116,600       0    0      58,300       0    0           0          0  0   0      result->score = get_game_over_score(victims, node->pov, node->ply);
       58,300    0    0           0       0    0           0       0    0           0          0  0   0      return result;
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    // Ignore noncapture moves when in quiescence.
   26,638,715    3    1   8,615,613       0    0           0       0    0   8,615,613    330,460  0   0    if (zero_victims(victims) && node->quiescence) {
            .    .    .           .       .    .           .       .    .           .          .  .   .      result->type = MOVE_IGNORE;
            .    .    .           .       .    .           .       .    .           .          .  .   .      return result;
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    // Check whether the board state has been repeated, this results in a draw.
            .    .    .           .       .    .           .       .    .           .          .  .   .    if (is_repeated(&(result->next_node.position), node->ply)) {
            8    0    0           0       0    0           8       0    0           0          0  0   0      result->type = MOVE_GAMEOVER;
           16    0    0          16       0    0           0       0    0           0          0  0   0      result->score = get_draw_score(&(result->next_node.position), node->ply);
            .    .    .           .       .    .           .       .    .           .          .  .   .      return result;
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    tbassert(victims.stomped == 0
            .    .    .           .       .    .           .       .    .           .          .  .   .             || color_of(victims.stomped) != node->fake_color_to_move,
            .    .    .           .       .    .           .       .    .           .          .  .   .             "stomped = %d, color = %d, fake_color_to_move = %d\n",
            .    .    .           .       .    .           .       .    .           .          .  .   .             victims.stomped, color_of(victims.stomped),
            .    .    .           .       .    .           .       .    .           .          .  .   .             node->fake_color_to_move);
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    // Check whether we caused our own piece to be zapped. This isn't considered
            .    .    .           .       .    .           .       .    .           .          .  .   .    //   a blunder if we also managed to stomp an enemy piece in the process.
    5,335,112    0    0           0       0    0           0       0    0   2,667,556    161,427  0   0    if (victims.stomped == 0 &&
    2,026,744    1    1     532,740       0    0           0       0    0     532,740    119,763  0   0        victims.zapped > 0 &&
            .    .    .           .       .    .           .       .    .           .          .  .   .        color_of(victims.zapped) == node->fake_color_to_move) {
            .    .    .           .       .    .           .       .    .           .          .  .   .      blunder = true;
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    // Do not consider moves that are blunders while in quiescence.
    1,178,849    3    1     381,684       0    0           0       0    0     381,684     38,211  0   0    if (node->quiescence && blunder) {
            .    .    .           .       .    .           .       .    .           .          .  .   .      result->type = MOVE_IGNORE;
            .    .    .           .       .    .           .       .    .           .          .  .   .      return result;
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    // Extend the search-depth by 1 if we captured a piece, since that means the
            .    .    .           .       .    .           .       .    .           .          .  .   .    //   move was interesting.
    4,975,305    0    0           0       0    0   3,980,244       0    0           0          0  0   0    if (victim_exists(victims) && !blunder) {
            .    .    .           .       .    .           .       .    .           .          .  .   .      ext = 1;
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    // Late move reductions - or LMR. Only done in scout search.
            .    .    .           .       .    .           .       .    .           .          .  .   .    int next_reduction = 0;
   10,315,531    1    1   4,960,425     634    0           0       0    0   2,677,553    212,274  0   0    if (type == SEARCH_SCOUT && node->legal_move_count + 1 >= LMR_R1 && node->depth > 2 &&
      361,612    0    0      90,403       0    0           0       0    0     180,806          1  0   0        zero_victims(victims) && mv != killer_a && mv != killer_b) {
            .    .    .           .       .    .           .       .    .           .          .  .   .      if (node->legal_move_count + 1 >= LMR_R2) {
            .    .    .           .       .    .           .       .    .           .          .  .   .        next_reduction = 2;
            .    .    .           .       .    .           .       .    .           .          .  .   .      } else {
      361,612    1    1      90,403       0    0           0       0    0           0          0  0   0        next_reduction = 1;
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
      995,061    1    1           0       0    0     995,061       0    0           0          0  0   0    result->type = MOVE_EVALUATED;
      995,061    0    0           0       0    0           0       0    0           0          0  0   0    int search_depth = ext + node->depth - 1;
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    // Check if we need to perform a reduced-depth search.
            .    .    .           .       .    .           .       .    .           .          .  .   .    //
            .    .    .           .       .    .           .       .    .           .          .  .   .    // After a reduced-depth search, a full-depth search will be performed if the
            .    .    .           .       .    .           .       .    .           .          .  .   .    //  reduced-depth search did not trigger a cut-off.
            .    .    .           .       .    .           .       .    .           .          .  .   .    if (next_reduction > 0) {
      271,209    0    0           0       0    0      90,403       0    0           0          0  0   0      search_depth -= next_reduction;
       90,403    0    0           0       0    0           0       0    0           0          0  0   0      int reduced_depth_score = -scout_search(&(result->next_node), search_depth,
            .    .    .           .       .    .           .       .    .           .          .  .   .                                              node_count_serial);
      271,209    0    0      90,403       0    0           0       0    0      90,403         74  0   0      if (reduced_depth_score < node->beta) {
       90,128    0    0           0       0    0      90,128       0    0           0          0  0   0        result->score = reduced_depth_score;
       90,128    0    0           0       0    0           0       0    0           0          0  0   0        return result;
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
            .    .    .           .       .    .           .       .    .           .          .  .   .      search_depth += next_reduction;
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    // Check if we should abort due to time control.
    1,809,866    0    0     904,933   5,984    0           0       0    0     904,933     44,572  0   0    if (abortf) {
            .    .    .           .       .    .           .       .    .           .          .  .   .      result->score = 0;
    8,171,624    1    1           0       0    0   8,171,624       0    0           0          0  0   0      result->type = MOVE_IGNORE;
    8,171,624    0    0           0       0    0           0       0    0           0          0  0   0      return result;
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  
    1,809,316    0    0           0       0    0           0       0    0     904,658        183  0   0    if (type == SEARCH_SCOUT) {
    3,589,972    0    0           0       0    0     897,493       0    0           0          0  0   0      result->score = -scout_search(&(result->next_node), search_depth,
            .    .    .           .       .    .           .       .    .           .          .  .   .                                   node_count_serial);
            .    .    .           .       .    .           .       .    .           .          .  .   .    } else {
       44,076    0    0      14,692       0    0           0       0    0      14,692        270  0   0      if (node->legal_move_count == 0 || node->quiescence) {
        2,177    0    0         311       0    0         622       0    0           0          0  0   0        result->score = -searchPV(&(result->next_node), search_depth, node_count_serial);
            .    .    .           .       .    .           .       .    .           .          .  .   .      } else {
       14,258    0    0           0       0    0       7,129       0    0           0          0  0   0        result->score = -scout_search(&(result->next_node), search_depth,
            .    .    .           .       .    .           .       .    .           .          .  .   .                              node_count_serial);
       14,258    0    0       7,129       0    0           0       0    0       7,129         44  0   0        if (result->score > node->alpha) {
    1,795,802    0    0         160       0    0     897,661       0    0           0          0  0   0          result->score = -searchPV(&(result->next_node), node->depth + ext - 1, node_count_serial);
            .    .    .           .       .    .           .       .    .           .          .  .   .        }
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    return result;
   84,394,881    1    1  65,640,463  58,497    0           0       0    0           0          0  0   0  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  // Incremental sort of the move list.
            .    .    .           .       .    .           .       .    .           .          .  .   .  void sort_incremental(sortable_move_t *move_list, int num_of_moves, int mv_index) {
   71,110,383    1    1           0       0    0           0       0    0  23,582,048    379,883  0   0    for (int j = 0; j < num_of_moves; j++) {
   67,723,761    1    1  23,217,809   9,640    0      14,417       0    0           0          0  0   0      sortable_move_t insert = move_list[j];
            .    .    .           .       .    .           .       .    .           .          .  .   .      int hole = j;
3,312,423,052    3    3 415,821,838       0    0           0       0    0 833,045,370 22,584,462  0   0      while (hole > 0 && insert > move_list[hole-1]) {
  394,384,379    0    0           0       0    0 394,384,379       0    0           0          0  0   0        move_list[hole] = move_list[hole-1];
            .    .    .           .       .    .           .       .    .           .          .  .   .        hole--;
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
   46,435,618    0    0           0       0    0  23,217,809       0    0           0          0  0   0      move_list[hole] = insert;
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  // Returns true if a cutoff was triggered, false otherwise.
            .    .    .           .       .    .           .       .    .           .          .  .   .  bool search_process_score(searchNode *node, move_t mv, int mv_index,
            .    .    .           .       .    .           .       .    .           .          .  .   .                                  moveEvaluationResult *result, searchType_t type) {
    3,174,407    9    2   2,106,738       0    0           0       0    0   1,053,369    228,929  0   0    if (result->score > node->best_score) {
      282,977    0    0           0       0    0     282,977       0    0           0          0  0   0      node->best_score = result->score;
      565,954    0    0     282,977   7,807    0     282,977       0    0           0          0  0   0      node->best_move_index = mv_index;
      565,954    0    0     282,977   8,172    0     282,977   3,728    0           0          0  0   0      node->subpv[0] = mv;
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .      // write best move into right position in PV buffer.
   32,125,299   15    7  14,714,804 157,478   50  14,878,002 153,821   40  15,846,712    315,961  0   0      memcpy(node->subpv + 1, result->next_node.subpv,
            .    .    .           .       .    .           .       .    .           .          .  .   .             sizeof(move_t) * (MAX_PLY_IN_SEARCH - 1));
      282,977    0    0           0       0    0     282,977       0    0           0          0  0   0      node->subpv[MAX_PLY_IN_SEARCH - 1] = 0;
            .    .    .           .       .    .           .       .    .           .          .  .   .  
        1,002    0    0         668      17    0           0       0    0         334         30  0   0      if (type != SEARCH_SCOUT && result->score > node->alpha) {
          308    0    0           0       0    0         308       0    0           0          0  0   0        node->alpha = result->score;
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
      848,597    0    0     565,620       0    0           0       0    0     282,977     71,094  0   0      if (result->score >= node->beta) {
    1,511,867    8    1     647,943   8,008    0           0       0    0     215,981     39,714  0   0        if (mv != killer[KMT(node->ply, 0)] && ENABLE_TABLES) {
      112,353    0    0           0       0    0      37,451       0    0           0          0  0   0          killer[KMT(node->ply, 1)] = killer[KMT(node->ply, 0)];
       37,451    0    0           0       0    0      37,451       0    0           0          0  0   0          killer[KMT(node->ply, 0)] = mv;
            .    .    .           .       .    .           .       .    .           .          .  .   .        }
            .    .    .           .       .    .           .       .    .           .          .  .   .        return true;
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .    return false;
            .    .    .           .       .    .           .       .    .           .          .  .   .  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  // Check if we should abort.
            .    .    .           .       .    .           .       .    .           .          .  .   .  bool should_abort_check() {
    2,986,299    1    1     995,433       0    0     995,433       0    0           0          0  0   0    tics++;
    1,991,109    1    1           0       0    0           0       0    0     995,433    249,206  0   0    if ((tics & ABORT_CHECK_PERIOD) == 0) {
          976    0    0         245       0    0         245       0    0         243         25  0   0      if (milliseconds() >= timeout) {
          243    0    0         243       0    0           0       0    0           0          0  0   0        abortf = true;
            .    .    .           .       .    .           .       .    .           .          .  .   .        return true;
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .    return false;
            .    .    .           .       .    .           .       .    .           .          .  .   .  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  // Obtain a sorted move list.
            .    .    .           .       .    .           .       .    .           .          .  .   .  static int get_sortable_move_list(searchNode *node, sortable_move_t * move_list,
    4,374,912    1    1           0       0    0   2,552,032       0    0           0          0  0   0                           int hash_table_move) {
            .    .    .           .       .    .           .       .    .           .          .  .   .    // number of moves in list
    1,822,880    0    0           0       0    0     729,152       0    0           0          0  0   0    int num_of_moves = generate_all(&(node->position), move_list, false);
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    color_t fake_color_to_move = color_to_move_of(&(node->position));
            .    .    .           .       .    .           .       .    .           .          .  .   .  
    1,458,304    0    0     729,152       0    0           0       0    0           0          0  0   0    move_t killer_a = killer[KMT(node->ply, 0)];
    1,093,728    0    0     364,576       0    0           0       0    0           0          0  0   0    move_t killer_b = killer[KMT(node->ply, 1)];
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .    // sort special moves to the front
   45,322,254    0    0           0       0    0           0       0    0  22,661,127    374,610  0   0    for (int mv_index = 0; mv_index < num_of_moves; mv_index++) {
   22,296,551    1    1  22,296,551       0    0           0       0    0           0          0  0   0      move_t mv = get_move(move_list[mv_index]);
   44,593,102    0    0           0       0    0           0       0    0  22,296,551     27,972  0   0      if (mv == hash_table_move) {
            .    .    .           .       .    .           .       .    .           .          .  .   .        set_sort_key(&move_list[mv_index], SORT_MASK);
   44,559,868    0    0           0       0    0           0       0    0  22,279,934    277,612  0   0      } else if (mv == killer_a) {
            .    .    .           .       .    .           .       .    .           .          .  .   .        set_sort_key(&move_list[mv_index], SORT_MASK - 1);
   44,009,482    1    1           0       0    0           0       0    0  22,004,741    234,474  0   0      } else if (mv == killer_b) {
            .    .    .           .       .    .           .       .    .           .          .  .   .        set_sort_key(&move_list[mv_index], SORT_MASK - 2);
            .    .    .           .       .    .           .       .    .           .          .  .   .      } else {
            .    .    .           .       .    .           .       .    .           .          .  .   .        ptype_t  pce = ptype_mv_of(mv);
            .    .    .           .       .    .           .       .    .           .          .  .   .        rot_t    ro  = rot_of(mv);   // rotation
            .    .    .           .       .    .           .       .    .           .          .  .   .        square_t fs  = from_square(mv);
   65,311,806    0    0           0       0    0           0       0    0           0          0  0   0        int      ot  = ORI_MASK & (ori_of(node->position.board[fs]) + ro);
            .    .    .           .       .    .           .       .    .           .          .  .   .        square_t ts  = to_square(mv);
            .    .    .           .       .    .           .       .    .           .          .  .   .        set_sort_key(&move_list[mv_index],
  111,405,042    1    1           0       0    0           0       0    0           0          0  0   0                     best_move_history[BMH(fake_color_to_move, pce, ts, ot)]);
            .    .    .           .       .    .           .       .    .           .          .  .   .      }
            .    .    .           .       .    .           .       .    .           .          .  .   .    }
            .    .    .           .       .    .           .       .    .           .          .  .   .    return num_of_moves;
    3,281,184    0    0   2,916,608       0    0           0       0    0           0          0  0   0  }
            .    .    .           .       .    .           .       .    .           .          .  .   .  
            .    .    .           .       .    .           .       .    .           .          .  .   .  

--------------------------------------------------------------------------------
-- Auto-annotated source: /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./move_gen.h
--------------------------------------------------------------------------------
         Ir I1mr ILmr         Dr D1mr DLmr         Dw   D1mw DLmw         Bc     Bcm Bi Bim 

-- line 149 ----------------------------------------
          .    .    .          .    .    .          .      .    .          .       .  .   .  } position_t;
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  // -----------------------------------------------------------------------------
          .    .    .          .    .    .          .      .    .          .       .  .   .  // Function prototypes
          .    .    .          .    .    .          .      .    .          .       .  .   .  // -----------------------------------------------------------------------------
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  char *color_to_str(color_t c);
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline color_t color_to_move_of(position_t *p) {
  1,093,731    1    1    364,577    1    0          0      0    0          0       0  0   0    if ((p->ply & 1) == 0) {
  1,458,308    0    0          0    0    0    364,577      0    0          0       0  0   0      return WHITE;
          .    .    .          .    .    .          .      .    .          .       .  .   .    } else {
          .    .    .          .    .    .          .      .    .          .       .  .   .      return BLACK;
          .    .    .          .    .    .          .      .    .          .       .  .   .    }
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline color_t color_of(piece_t x) {
 16,893,807   13    3          0    0    0          0      0    0          0       0  0   0    return (color_t) ((x >> COLOR_SHIFT) & COLOR_MASK);
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline color_t opp_color(color_t c) {
     18,380    0    0          0    0    0          0      0    0          0       0  0   0    if (c == WHITE) {
 12,413,998    0    0          0    0    0 11,666,464 63,683   24 11,666,464 364,616  0   0      return BLACK;
          .    .    .          .    .    .          .      .    .          .       .  .   .    } else {
          .    .    .          .    .    .          .      .    .          .       .  .   .      return WHITE;
          .    .    .          .    .    .          .      .    .          .       .  .   .    }
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline void set_color(piece_t *x, color_t c) {
          .    .    .          .    .    .          .      .    .          .       .  .   .    tbassert((c >= 0) & (c <= COLOR_MASK), "color: %d\n", c);
         16    0    0          0    0    0          0      0    0          0       0  0   0    *x = ((c & COLOR_MASK) << COLOR_SHIFT) |
          .    .    .          .    .    .          .      .    .          .       .  .   .        (*x & ~(COLOR_MASK << COLOR_SHIFT));
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline ptype_t ptype_of(piece_t x) {
412,532,925    3    3          0    0    0          0      0    0          0       0  0   0    return (ptype_t) ((x >> PTYPE_SHIFT) & PTYPE_MASK);
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline void set_ptype(piece_t *x, ptype_t pt) {
        278    6    6        118    5    4         16      0    0          2       1  0   0    *x = ((pt & PTYPE_MASK) << PTYPE_SHIFT) |
          .    .    .          .    .    .          .      .    .          .       .  .   .        (*x & ~(PTYPE_MASK << PTYPE_SHIFT));
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline int ori_of(piece_t x) {
 34,783,486    0    0 25,405,787    0    0          0      0    0          0       0  0   0    return (x >> ORI_SHIFT) & ORI_MASK;
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline void set_ori(piece_t *x, int ori) {
  9,865,642    1    1          0    0    0         16      0    0          0       0  0   0    *x = ((ori & ORI_MASK) << ORI_SHIFT) |
          .    .    .          .    .    .          .      .    .          .       .  .   .        (*x & ~(ORI_MASK << ORI_SHIFT));
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  void init_zob();
          .    .    .          .    .    .          .      .    .          .       .  .   .  // For no square, use 0, which is guaranteed to be off board
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline static square_t square_of(fil_t f, rnk_t r) {
 36,458,116    3    3          0    0    0          0      0    0          0       0  0   0    square_t s = ARR_WIDTH * (FIL_ORIGIN + f) + RNK_ORIGIN + r;
          .    .    .          .    .    .          .      .    .          .       .  .   .    DEBUG_LOG(1, "Square of (file %d, rank %d) is %d\n", f, r, s);
          .    .    .          .    .    .          .      .    .          .       .  .   .    tbassert((s >= 0) && (s < ARR_SIZE), "s: %d\n", s);
          .    .    .          .    .    .          .      .    .          .       .  .   .    return s;
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  // Finds file of square
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline fil_t fil_of_old(square_t sq) {
          .    .    .          .    .    .          .      .    .          .       .  .   .    fil_t f = ((sq >> FIL_SHIFT) & FIL_MASK) - FIL_ORIGIN;
-- line 212 ----------------------------------------
-- line 229 ----------------------------------------
          .    .    .          .    .    .          .      .    .          .       .  .   .  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
          .    .    .          .    .    .          .      .    .          .       .  .   .  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
          .    .    .          .    .    .          .      .    .          .       .  .   .  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
          .    .    .          .    .    .          .      .    .          .       .  .   .  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
          .    .    .          .    .    .          .      .    .          .       .  .   .  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
          .    .    .          .    .    .          .      .    .          .       .  .   .  };
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline static fil_t fil_of(square_t sq) {
        108    1    1         54   28    4          0      0    0          0       0  0   0    fil_t f = fil_of_table[sq];
          .    .    .          .    .    .          .      .    .          .       .  .   .    DEBUG_LOG(1, "File of square %d is %d\n", sq, f);
          .    .    .          .    .    .          .      .    .          .       .  .   .    return f;
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  // Finds rank of square
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline rnk_t rnk_of_old(square_t sq) {
          .    .    .          .    .    .          .      .    .          .       .  .   .    rnk_t r = ((sq >> RNK_SHIFT) & RNK_MASK) - RNK_ORIGIN;
          .    .    .          .    .    .          .      .    .          .       .  .   .    DEBUG_LOG(1, "Rank of square %d is %d\n", sq, r);
          .    .    .          .    .    .          .      .    .          .       .  .   .    return r;
-- line 245 ----------------------------------------
-- line 260 ----------------------------------------
          .    .    .          .    .    .          .      .    .          .       .  .   .  -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
          .    .    .          .    .    .          .      .    .          .       .  .   .  -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
          .    .    .          .    .    .          .      .    .          .       .  .   .  -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
          .    .    .          .    .    .          .      .    .          .       .  .   .  -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
          .    .    .          .    .    .          .      .    .          .       .  .   .  -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12
          .    .    .          .    .    .          .      .    .          .       .  .   .  };
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline static rnk_t rnk_of(square_t sq) {
         54    9    1         54   29    4          0      0    0          0       0  0   0    rnk_t r = rnk_of_table[sq];
          .    .    .          .    .    .          .      .    .          .       .  .   .    DEBUG_LOG(1, "Rank of square %d is %d\n", sq, r);
          .    .    .          .    .    .          .      .    .          .       .  .   .    return r;
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  int square_to_str(square_t sq, char *buf, size_t bufsize);
          .    .    .          .    .    .          .      .    .          .       .  .   .  // direction map
          .    .    .          .    .    .          .      .    .          .       .  .   .  static int dir[8] = { -ARR_WIDTH - 1, -ARR_WIDTH, -ARR_WIDTH + 1, -1, 1,
          .    .    .          .    .    .          .      .    .          .       .  .   .                        ARR_WIDTH - 1, ARR_WIDTH, ARR_WIDTH + 1 };
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline static int dir_of(int i) {
-- line 276 ----------------------------------------
-- line 295 ----------------------------------------
          .    .    .          .    .    .          .      .    .          .       .  .   .    { NN, -1, -1, SS},   // EE
          .    .    .          .    .    .          .      .    .          .       .  .   .    { WW, EE, -1, -1 },  // SS
          .    .    .          .    .    .          .      .    .          .       .  .   .    { -1, NN, SS, -1 }   // WW
          .    .    .          .    .    .          .      .    .          .       .  .   .  };
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline static int reflect_of(int beam_dir, int pawn_ori) {
          .    .    .          .    .    .          .      .    .          .       .  .   .    tbassert(beam_dir >= 0 && beam_dir < NUM_ORI, "beam-dir: %d\n", beam_dir);
          .    .    .          .    .    .          .      .    .          .       .  .   .    tbassert(pawn_ori >= 0 && pawn_ori < NUM_ORI, "pawn-ori: %d\n", pawn_ori);
 28,733,244    0    0  7,183,311  159    1          0      0    0          0       0  0   0    return reflect[beam_dir][pawn_ori];
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  // -----------------------------------------------------------------------------
          .    .    .          .    .    .          .      .    .          .       .  .   .  // Move getters and setters.
          .    .    .          .    .    .          .      .    .          .       .  .   .  // -----------------------------------------------------------------------------
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline ptype_t ptype_mv_of(move_t mv) {
          .    .    .          .    .    .          .      .    .          .       .  .   .    return (ptype_t) ((mv >> PTYPE_MV_SHIFT) & PTYPE_MV_MASK);
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline square_t from_square(move_t mv) {
  9,377,816    0    0          0    0    0          0      0    0          0       0  0   0    return (mv >> FROM_SHIFT) & FROM_MASK;
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline square_t to_square(move_t mv) {
  9,377,738    0    0          0    0    0          0      0    0          0       0  0   0    return (mv >> TO_SHIFT) & TO_MASK;
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline rot_t rot_of(move_t mv) {
  3,288,574    0    0          0    0    0          0      0    0          0       0  0   0    return (rot_t) ((mv >> ROT_SHIFT) & ROT_MASK);
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline move_t move_of(ptype_t typ, rot_t rot, square_t from_sq, square_t to_sq) {
 27,325,439    0    0 19,417,635    0    0          0      0    0          0       0  0   0    return ((typ & PTYPE_MV_MASK) << PTYPE_MV_SHIFT) |
 35,772,538   11    1  5,637,260    0    0  8,599,328      0    0          0       0  0   0        ((rot & ROT_MASK) << ROT_SHIFT) |
 16,903,226    1    1    198,101    0    0          0      0    0          0       0  0   0        ((from_sq & FROM_MASK) << FROM_SHIFT) |
          .    .    .          .    .    .          .      .    .          .       .  .   .        ((to_sq & TO_MASK) << TO_SHIFT);
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  void move_to_str(move_t mv, char *buf, size_t bufsize);
          .    .    .          .    .    .          .      .    .          .       .  .   .  int generate_all(position_t *p, sortable_move_t *sortable_move_list,
          .    .    .          .    .    .          .      .    .          .       .  .   .                   bool strict);
          .    .    .          .    .    .          .      .    .          .       .  .   .  void do_perft(position_t *gme, int depth, int ply);
          .    .    .          .    .    .          .      .    .          .       .  .   .  square_t low_level_make_move(position_t *old, position_t *p, move_t mv);
          .    .    .          .    .    .          .      .    .          .       .  .   .  victims_t make_move(position_t *old, position_t *p, move_t mv);
-- line 336 ----------------------------------------
-- line 341 ----------------------------------------
          .    .    .          .    .    .          .      .    .          .       .  .   .  victims_t ILLEGAL();
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  bool is_ILLEGAL(victims_t victims);
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline bool is_KO(victims_t victims) {
          .    .    .          .    .    .          .      .    .          .       .  .   .    return (victims.stomped == KO_STOMPED) ||
          .    .    .          .    .    .          .      .    .          .       .  .   .        (victims.zapped == KO_ZAPPED);
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  inline bool zero_victims(victims_t victims) {
 17,572,954    0    0  8,786,477    0    0          0      0    0  8,786,477  18,709  0   0    return (victims.stomped == 0) &&
          .    .    .          .    .    .          .      .    .          .       .  .   .        (victims.zapped == 0);
          .    .    .          .    .    .          .      .    .          .       .  .   .  }
          .    .    .          .    .    .          .      .    .          .       .  .   .  bool victim_exists(victims_t victims);
          .    .    .          .    .    .          .      .    .          .       .  .   .  
          .    .    .          .    .    .          .      .    .          .       .  .   .  int mark_laser_path(position_t *p, char *laser_map, color_t c,
          .    .    .          .    .    .          .      .    .          .       .  .   .                       char mark_mask);
          .    .    .          .    .    .          .      .    .          .       .  .   .  #endif  // MOVE_GEN_H

--------------------------------------------------------------------------------
-- Auto-annotated source: /afs/athena.mit.edu/user/h/o/hongyis/project4/player/./search_scout.c
--------------------------------------------------------------------------------
        Ir I1mr ILmr         Dr   D1mr DLmr         Dw   D1mw DLmw         Bc       Bcm Bi Bim 

-- line 6 ----------------------------------------
         .    .    .          .      .    .          .      .    .          .         .  .   .  //   parallelize scout search separately from searchPV.
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .  #include "./tbassert.h"
         .    .    .          .      .    .          .      .    .          .         .  .   .  #include "./simple_mutex.h"
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .  // Checks whether a node's parent has aborted.
         .    .    .          .      .    .          .      .    .          .         .  .   .  //   If this occurs, we should just stop and return 0 immediately.
         .    .    .          .      .    .          .      .    .          .         .  .   .  bool parallel_parent_aborted(searchNode* node) {
 1,410,021    0    0  1,410,021 56,785    0          0      0    0          0         0  0   0    searchNode* pred = node->parent;
37,293,270   11    4  1,002,562    492    0    105,069      0    0 17,900,504 2,279,262  0   0    while (pred != NULL) {
42,127,408   10    3 16,490,240 36,127    0          0      0    0 16,490,240   979,075  0   0      if (pred->abort) {
         .    .    .          .      .    .          .      .    .          .         .  .   .        return true;
         .    .    .          .      .    .          .      .    .          .         .  .   .      }
16,490,240    0    0 16,490,240 69,538    0          0      0    0          0         0  0   0      pred = pred->parent;
         .    .    .          .      .    .          .      .    .          .         .  .   .    }
         .    .    .          .      .    .          .      .    .          .         .  .   .    return false;
         .    .    .          .      .    .          .      .    .          .         .  .   .  }
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .  // Checks whether this node has aborted due to a cut-off.
         .    .    .          .      .    .          .      .    .          .         .  .   .  //   If this occurs, we should actually return the score.
         .    .    .          .      .    .          .      .    .          .         .  .   .  bool parallel_node_aborted(searchNode* node) {
         .    .    .          .      .    .          .      .    .          .         .  .   .    if (node->abort) {
-- line 27 ----------------------------------------
-- line 29 ----------------------------------------
         .    .    .          .      .    .          .      .    .          .         .  .   .    }
         .    .    .          .      .    .          .      .    .          .         .  .   .    return false;
         .    .    .          .      .    .          .      .    .          .         .  .   .  }
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .  // Initialize a scout search node for a "Null Window" search.
         .    .    .          .      .    .          .      .    .          .         .  .   .  //   https://chessprogramming.wikispaces.com/Scout
         .    .    .          .      .    .          .      .    .          .         .  .   .  //   https://chessprogramming.wikispaces.com/Null+Window
         .    .    .          .      .    .          .      .    .          .         .  .   .  static void initialize_scout_node(searchNode *node, int depth) {
   995,433    0    0          0      0    0    995,433      0    0          0         0  0   0    node->type = SEARCH_SCOUT;
 4,977,165    3    3  1,990,866      0    0    995,433      0    0          0         0  0   0    node->beta = -(node->parent->alpha);
 1,990,866    1    1          0      0    0    995,433      0    0          0         0  0   0    node->alpha = node->beta - 1;
   904,622    0    0          0      0    0    904,622      0    0          0         0  0   0    node->depth = depth;
 2,986,299    1    1    995,433      0    0    995,433      0    0          0         0  0   0    node->ply = node->parent->ply + 1;
   995,433    1    1          0      0    0    995,433      6    0          0         0  0   0    node->subpv[0] = 0;
   995,433    0    0          0      0    0    995,433      0    0          0         0  0   0    node->legal_move_count = 0;
 2,987,115    0    0    995,841      0    0    995,841      0    0          0         0  0   0    node->fake_color_to_move = color_to_move_of(&(node->position));
         .    .    .          .      .    .          .      .    .          .         .  .   .    // point of view = 1 for white, -1 for black
 3,981,732    2    2          0      0    0    995,433      0    0          0         0  0   0    node->pov = 1 - node->fake_color_to_move * 2;
   995,433    0    0          0      0    0    995,433      0    0          0         0  0   0    node->best_move_index = 0;  // index of best move found
   995,433    7    1          0      0    0    995,433      0    0          0         0  0   0    node->abort = false;
         .    .    .          .      .    .          .      .    .          .         .  .   .  }
         .    .    .          .      .    .          .      .    .          .         .  .   .  
10,949,763    8    1          0      0    0  7,963,464 17,249   20          0         0  0   0  static score_t scout_search(searchNode *node, int depth,
         .    .    .          .      .    .          .      .    .          .         .  .   .                              uint64_t *node_count_serial) {
         .    .    .          .      .    .          .      .    .          .         .  .   .    // Initialize the search node.
         .    .    .          .      .    .          .      .    .          .         .  .   .    initialize_scout_node(node, depth);
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .    // check whether we should abort
         .    .    .          .      .    .          .      .    .          .         .  .   .    if (should_abort_check() || parallel_parent_aborted(node)) {
         .    .    .          .      .    .          .      .    .          .         .  .   .      return 0;
         .    .    .          .      .    .          .      .    .          .         .  .   .    }
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .    // Pre-evaluate this position.
 2,986,299    0    0          0      0    0    995,433      0    0          0         0  0   0    leafEvalResult pre_evaluation_result = evaluate_as_leaf(node, SEARCH_SCOUT);
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .    // If we decide to stop searching, return the pre-evaluation score.
 3,981,732    0    0          0      0    0          0      0    0    995,433        36  0   0    if (pre_evaluation_result.type == MOVE_EVALUATED) {
         .    .    .          .      .    .          .      .    .          .         .  .   .      return pre_evaluation_result.score;
         .    .    .          .      .    .          .      .    .          .         .  .   .    }
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .    // Populate some of the fields of this search node, using some
         .    .    .          .      .    .          .      .    .          .         .  .   .    //  of the information provided by the pre-evaluation.
   728,478    0    0          0      0    0          0      0    0          0         0  0   0    int hash_table_move = pre_evaluation_result.hash_table_move;
   364,239    0    0          0      0    0    364,239      0    0          0         0  0   0    node->best_score = pre_evaluation_result.score;
   728,478    0    0          0      0    0    364,239      0    0          0         0  0   0    node->quiescence = pre_evaluation_result.should_enter_quiescence;
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .    // Grab the killer-moves for later use.
 1,821,195    8    1    728,478 30,696    3    364,239      0    0          0         0  0   0    move_t killer_a = killer[KMT(node->ply, 0)];
 1,456,956    1    1    364,239      0    0    364,239      0    0          0         0  0   0    move_t killer_b = killer[KMT(node->ply, 1)];
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .    // Store the sorted move list on the stack.
         .    .    .          .      .    .          .      .    .          .         .  .   .    //   MAX_NUM_MOVES is all that we need.
         .    .    .          .      .    .          .      .    .          .         .  .   .    sortable_move_t move_list[MAX_NUM_MOVES];
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .    // Obtain the sorted move list.
 1,456,956    0    0          0      0    0    364,239      0    0          0         0  0   0    int num_of_moves = get_sortable_move_list(node, move_list, hash_table_move);
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .    int number_of_moves_evaluated = 0;
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .    // A simple mutex. See simple_mutex.h for implementation details.
         .    .    .          .      .    .          .      .    .          .         .  .   .    simple_mutex_t node_mutex;
         .    .    .          .      .    .          .      .    .          .         .  .   .    init_simple_mutex(&node_mutex);
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .    // Sort the move list.
         .    .    .          .      .    .          .      .    .          .         .  .   .    sort_incremental(move_list, num_of_moves, number_of_moves_evaluated);
         .    .    .          .      .    .          .      .    .          .         .  .   .    
 2,185,434    0    0          0      0    0    728,478      0    0          0         0  0   0    moveEvaluationResult* result = (moveEvaluationResult *) malloc(sizeof(moveEvaluationResult));
         .    .    .          .      .    .          .      .    .          .         .  .   .  
18,293,856    0    0  9,146,928  2,651    0          0      0    0  9,146,928   148,626  0   0    for (int mv_index = 0; mv_index < num_of_moves; mv_index++) {
         .    .    .          .      .    .          .      .    .          .         .  .   .      // Get the next move from the move list.
         .    .    .          .      .    .          .      .    .          .         .  .   .      int local_index = number_of_moves_evaluated++;
         .    .    .          .      .    .          .      .    .          .         .  .   .      move_t mv = get_move(move_list[local_index]);
         .    .    .          .      .    .          .      .    .          .         .  .   .  
46,813,960    1    1  9,362,792      0    0 18,725,584  5,446    0  9,362,792         6  0   0      if (TRACE_MOVES) {
         .    .    .          .      .    .          .      .    .          .         .  .   .        print_move_info(mv, node->ply);
         .    .    .          .      .    .          .      .    .          .         .  .   .      }
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .      // increase node count
18,725,584    0    0 28,088,376      0    0          0      0    0  9,362,792        25  0   0      __sync_fetch_and_add(node_count_serial, 1);
         .    .    .          .      .    .          .      .    .          .         .  .   .  
84,265,128    1    1 28,088,376      0    0 18,725,584      0    0          0         0  0   0      result = evaluateMove(node, mv, killer_a, killer_b,
         .    .    .          .      .    .          .      .    .          .         .  .   .                                                 SEARCH_SCOUT,
         .    .    .          .      .    .          .      .    .          .         .  .   .                                                 node_count_serial,result);
         .    .    .          .      .    .          .      .    .          .         .  .   .  
37,451,168    0    0  9,362,792      0    0          0      0    0  9,362,792    13,289  0   0      if (result->type == MOVE_ILLEGAL || result->type == MOVE_IGNORE
 2,091,564    0    0  1,045,782 86,635    0          0      0    0  1,045,782         0  0   0          || abortf || parallel_parent_aborted(node)) {
         .    .    .          .      .    .          .      .    .          .         .  .   .        continue;
         .    .    .          .      .    .          .      .    .          .         .  .   .      }
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .      // A legal move is a move that's not KO, but when we are in quiescence
         .    .    .          .      .    .          .      .    .          .         .  .   .      // we only want to count moves that has a capture.
 2,091,564    8    1          0      0    0          0      0    0  1,045,782    58,363  0   0      if (result->type == MOVE_EVALUATED) {
   987,621    0    0    987,621      0    0          0      0    0          0         0  0   0        node->legal_move_count++;
         .    .    .          .      .    .          .      .    .          .         .  .   .      }
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .      // process the score. Note that this mutates fields in node.
         .    .    .          .      .    .          .      .    .          .         .  .   .      bool cutoff = search_process_score(node, mv, local_index, result, SEARCH_SCOUT);
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .      if (cutoff) {
   431,728    0    0          0      0    0    215,864      0    0          0         0  0   0        node->abort = true;
         .    .    .          .      .    .          .      .    .          .         .  .   .        break;
         .    .    .          .      .    .          .      .    .          .         .  .   .      }
         .    .    .          .      .    .          .      .    .          .         .  .   .    }
         .    .    .          .      .    .          .      .    .          .         .  .   .  
   728,478    0    0          0      0    0    364,239      0    0          0         0  0   0    free(result);
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .    if (parallel_parent_aborted(node)) {
         .    .    .          .      .    .          .      .    .          .         .  .   .      return 0;
         .    .    .          .      .    .          .      .    .          .         .  .   .    }
         .    .    .          .      .    .          .      .    .          .         .  .   .  
 1,092,717    1    1    364,239      0    0          0      0    0    364,239   146,914  0   0    if (node->quiescence == false) {
   151,130    0    0    151,130      0    0          0      0    0          0         0  0   0      update_best_move_history(&(node->position), node->best_move_index,
         .    .    .          .      .    .          .      .    .          .         .  .   .                               move_list, number_of_moves_evaluated);
         .    .    .          .      .    .          .      .    .          .         .  .   .    }
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .    tbassert(abs(node->best_score) != -INF, "best_score = %d\n",
         .    .    .          .      .    .          .      .    .          .         .  .   .             node->best_score);
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .    // Reads node->position.key, node->depth, node->best_score, and node->ply
   728,478    0    0          0      0    0    364,239      0    0          0         0  0   0    update_transposition_table(node);
         .    .    .          .      .    .          .      .    .          .         .  .   .  
   728,478    0    0    364,239      0    0          0      0    0          0         0  0   0    return node->best_score;
 7,963,464    0    0  6,968,031 86,452    0          0      0    0          0         0  0   0  }
         .    .    .          .      .    .          .      .    .          .         .  .   .  
         .    .    .          .      .    .          .      .    .          .         .  .   .  

--------------------------------------------------------------------------------
-- Auto-annotated source: /afs/athena.mit.edu/user/h/o/hongyis/project4/player/././move_gen.h
--------------------------------------------------------------------------------
        Ir I1mr ILmr         Dr   D1mr DLmr        Dw D1mw DLmw         Bc     Bcm Bi Bim 

-- line 149 ----------------------------------------
         .    .    .          .      .    .         .    .    .          .       .  .   .  } position_t;
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  // -----------------------------------------------------------------------------
         .    .    .          .      .    .         .    .    .          .       .  .   .  // Function prototypes
         .    .    .          .      .    .         .    .    .          .       .  .   .  // -----------------------------------------------------------------------------
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  char *color_to_str(color_t c);
         .    .    .          .      .    .         .    .    .          .       .  .   .  inline color_t color_to_move_of(position_t *p) {
 3,022,648    3    3  1,511,324  3,243    0 1,511,324  127    4          0       0  0   0    if ((p->ply & 1) == 0) {
   729,152    0    0    364,576      0    0         0    0    0          0       0  0   0      return WHITE;
         .    .    .          .      .    .         .    .    .          .       .  .   .    } else {
         .    .    .          .      .    .         .    .    .          .       .  .   .      return BLACK;
         .    .    .          .      .    .         .    .    .          .       .  .   .    }
         .    .    .          .      .    .         .    .    .          .       .  .   .  }
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  inline color_t color_of(piece_t x) {
 1,598,220    0    0          0      0    0         0    0    0          0       0  0   0    return (color_t) ((x >> COLOR_SHIFT) & COLOR_MASK);
         .    .    .          .      .    .         .    .    .          .       .  .   .  }
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  inline color_t opp_color(color_t c) {
         .    .    .          .      .    .         .    .    .          .       .  .   .    if (c == WHITE) {
         .    .    .          .      .    .         .    .    .          .       .  .   .      return BLACK;
         .    .    .          .      .    .         .    .    .          .       .  .   .    } else {
         .    .    .          .      .    .         .    .    .          .       .  .   .      return WHITE;
         .    .    .          .      .    .         .    .    .          .       .  .   .    }
-- line 173 ----------------------------------------
-- line 177 ----------------------------------------
         .    .    .          .      .    .         .    .    .          .       .  .   .  inline void set_color(piece_t *x, color_t c) {
         .    .    .          .      .    .         .    .    .          .       .  .   .    tbassert((c >= 0) & (c <= COLOR_MASK), "color: %d\n", c);
         .    .    .          .      .    .         .    .    .          .       .  .   .    *x = ((c & COLOR_MASK) << COLOR_SHIFT) |
         .    .    .          .      .    .         .    .    .          .       .  .   .        (*x & ~(COLOR_MASK << COLOR_SHIFT));
         .    .    .          .      .    .         .    .    .          .       .  .   .  }
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  inline ptype_t ptype_of(piece_t x) {
27,676,428    0    0          0      0    0         0    0    0          0       0  0   0    return (ptype_t) ((x >> PTYPE_SHIFT) & PTYPE_MASK);
         .    .    .          .      .    .         .    .    .          .       .  .   .  }
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  inline void set_ptype(piece_t *x, ptype_t pt) {
         .    .    .          .      .    .         .    .    .          .       .  .   .    *x = ((pt & PTYPE_MASK) << PTYPE_SHIFT) |
         .    .    .          .      .    .         .    .    .          .       .  .   .        (*x & ~(PTYPE_MASK << PTYPE_SHIFT));
         .    .    .          .      .    .         .    .    .          .       .  .   .  }
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  inline int ori_of(piece_t x) {
22,670,534    0    0 22,670,534 10,188    0         0    0    0          0       0  0   0    return (x >> ORI_SHIFT) & ORI_MASK;
         .    .    .          .      .    .         .    .    .          .       .  .   .  }
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  inline void set_ori(piece_t *x, int ori) {
         .    .    .          .      .    .         .    .    .          .       .  .   .    *x = ((ori & ORI_MASK) << ORI_SHIFT) |
         .    .    .          .      .    .         .    .    .          .       .  .   .        (*x & ~(ORI_MASK << ORI_SHIFT));
         .    .    .          .      .    .         .    .    .          .       .  .   .  }
         .    .    .          .      .    .         .    .    .          .       .  .   .  void init_zob();
         .    .    .          .      .    .         .    .    .          .       .  .   .  // For no square, use 0, which is guaranteed to be off board
-- line 202 ----------------------------------------
-- line 302 ----------------------------------------
         .    .    .          .      .    .         .    .    .          .       .  .   .    tbassert(pawn_ori >= 0 && pawn_ori < NUM_ORI, "pawn-ori: %d\n", pawn_ori);
         .    .    .          .      .    .         .    .    .          .       .  .   .    return reflect[beam_dir][pawn_ori];
         .    .    .          .      .    .         .    .    .          .       .  .   .  }
         .    .    .          .      .    .         .    .    .          .       .  .   .  // -----------------------------------------------------------------------------
         .    .    .          .      .    .         .    .    .          .       .  .   .  // Move getters and setters.
         .    .    .          .      .    .         .    .    .          .       .  .   .  // -----------------------------------------------------------------------------
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  inline ptype_t ptype_mv_of(move_t mv) {
45,341,068    0    0          0      0    0         0    0    0          0       0  0   0    return (ptype_t) ((mv >> PTYPE_MV_SHIFT) & PTYPE_MV_MASK);
         .    .    .          .      .    .         .    .    .          .       .  .   .  }
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  inline square_t from_square(move_t mv) {
         .    .    .          .      .    .         .    .    .          .       .  .   .    return (mv >> FROM_SHIFT) & FROM_MASK;
         .    .    .          .      .    .         .    .    .          .       .  .   .  }
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  inline square_t to_square(move_t mv) {
         .    .    .          .      .    .         .    .    .          .       .  .   .    return (mv >> TO_SHIFT) & TO_MASK;
         .    .    .          .      .    .         .    .    .          .       .  .   .  }
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  inline rot_t rot_of(move_t mv) {
22,670,534    0    0          0      0    0         0    0    0          0       0  0   0    return (rot_t) ((mv >> ROT_SHIFT) & ROT_MASK);
         .    .    .          .      .    .         .    .    .          .       .  .   .  }
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  inline move_t move_of(ptype_t typ, rot_t rot, square_t from_sq, square_t to_sq) {
         .    .    .          .      .    .         .    .    .          .       .  .   .    return ((typ & PTYPE_MV_MASK) << PTYPE_MV_SHIFT) |
         .    .    .          .      .    .         .    .    .          .       .  .   .        ((rot & ROT_MASK) << ROT_SHIFT) |
         .    .    .          .      .    .         .    .    .          .       .  .   .        ((from_sq & FROM_MASK) << FROM_SHIFT) |
         .    .    .          .      .    .         .    .    .          .       .  .   .        ((to_sq & TO_MASK) << TO_SHIFT);
         .    .    .          .      .    .         .    .    .          .       .  .   .  }
-- line 330 ----------------------------------------
-- line 337 ----------------------------------------
         .    .    .          .      .    .         .    .    .          .       .  .   .  void display(position_t *p);
         .    .    .          .      .    .         .    .    .          .       .  .   .  uint64_t compute_zob_key(position_t *p);
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  victims_t KO();
         .    .    .          .      .    .         .    .    .          .       .  .   .  victims_t ILLEGAL();
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  bool is_ILLEGAL(victims_t victims);
         .    .    .          .      .    .         .    .    .          .       .  .   .  inline bool is_KO(victims_t victims) {
37,206,350    0    0          0      0    0         0    0    0 18,603,175     113  0   0    return (victims.stomped == KO_STOMPED) ||
         .    .    .          .      .    .         .    .    .          .       .  .   .        (victims.zapped == KO_ZAPPED);
         .    .    .          .      .    .         .    .    .          .       .  .   .  }
         .    .    .          .      .    .         .    .    .          .       .  .   .  inline bool zero_victims(victims_t victims) {
60,996,505    6    6 10,047,270 18,439    0         0    0    0 27,986,437 833,381  0   0    return (victims.stomped == 0) &&
         .    .    .          .      .    .         .    .    .          .       .  .   .        (victims.zapped == 0);
         .    .    .          .      .    .         .    .    .          .       .  .   .  }
         .    .    .          .      .    .         .    .    .          .       .  .   .  bool victim_exists(victims_t victims);
         .    .    .          .      .    .         .    .    .          .       .  .   .  
         .    .    .          .      .    .         .    .    .          .       .  .   .  int mark_laser_path(position_t *p, char *laser_map, color_t c,
         .    .    .          .      .    .         .    .    .          .       .  .   .                       char mark_mask);
         .    .    .          .      .    .         .    .    .          .       .  .   .  #endif  // MOVE_GEN_H

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /build/buildd/eglibc-2.19/gmon/../sysdeps/x86_64/_mcount.S
  /build/buildd/eglibc-2.19/gmon/mcount.c
  /build/buildd/eglibc-2.19/malloc/malloc.c

--------------------------------------------------------------------------------
Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim 
--------------------------------------------------------------------------------
91   18   12 81   83    1 85   57    1 95  99  0   0  percentage of events annotated

